/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/var idCounter = 0;var ID_PREFIX = "resource";/** * Main initialization method. To be called when loading * of the document, including all scripts, is completed. */function init() {	/* When the blank image url is not set programatically to a local	 * representation, a spacer gif on the site of ext is loaded from the	 * internet. This causes problems when internet or the ext site are not	 * available. */	Ext.BLANK_IMAGE_URL = (ORYX.CONFIG.BLANK_IMAGE) || (ORYX.PATH + 'libs/ext-2.0.2/resources/images/default/s.gif');			ORYX.Log.debug("Querying editor instances");	// Hack for WebKit to set the SVGElement-Classes	ORYX.Editor.setMissingClasses();        // If someone wants to create the editor instance himself    if (window.onOryxResourcesLoaded) {        window.onOryxResourcesLoaded();    }     // Else if this is a newly created model    else if(window.location.pathname.include(ORYX.CONFIG.ORYX_NEW_URL)){        new ORYX.Editor({            id: 'oryx-canvas123',            fullscreen: true,            stencilset: {                url: "/oryx" + ORYX.Utils.getParamFromUrl("stencilset")            }        });    }     // Else fetch the model from server and display editor    else {        //HACK for distinguishing between different backends		// Backend of 2008 uses /self URL ending	    var modelUrl = window.location.href.replace(/#.*/g, "");		if(modelUrl.endsWith("/self")) {			modelUrl = modelUrl.replace("/self","/json");		} else {			modelUrl += "&data";		}        ORYX.Editor.createByUrl(modelUrl, {            id: modelUrl        });    }}/**   @namespace Global Oryx name space   @name ORYX*/if(!ORYX) {var ORYX = {};}/** * The Editor class. * @class ORYX.Editor * @extends Clazz * @param {Object} config An editor object, passed to {@link ORYX.Editor#loadSerialized} * @param {String} config.id Any ID that can be used inside the editor. If fullscreen=false, any HTML node with this id must be present to render the editor to this node. * @param {boolean} [config.fullscreen=true] Render editor in fullscreen mode or not. * @param {String} config.stencilset.url Stencil set URL. * @param {String} [config.stencil.id] Stencil type used for creating the canvas.   * @param {Object} config.properties Any properties applied to the canvas.*/ORYX.Editor = {    /** @lends ORYX.Editor.prototype */	// Defines the global dom event listener 	DOMEventListeners: new Hash(),	// Defines the selection	selection: [],		// Defines the current zoom level	zoomLevel:1.0,	construct: function(config) {				// initialization.		this._eventsQueue 	= [];		this.loadedPlugins 	= [];		this.pluginsData 	= [];						//meta data about the model for the signavio warehouse		//directory, new, name, description, revision, model (the model data)				this.modelMetaData = config;				var model = config;		if(config.model) {			model = config.model;		}				this.id = model.resourceId;        if(!this.id) {        	this.id = model.id;        	if(!this.id) {        		this.id = ORYX.Editor.provideId();        	}        }		        // Defines if the editor should be fullscreen or not		this.fullscreen = config.fullscreen !== false;				if (Signavio&&Signavio.Helper&&Signavio.Helper.ShowMask instanceof Function) {			Signavio.Helper.ShowMask(true, !this.fullscreen ? this.id : Ext.getBody());		}				// Initialize the eventlistener		this._initEventListener();		// Load particular stencilset		if(ORYX.CONFIG.BACKEND_SWITCH) {			var ssUrl = (model.stencilset.namespace||model.stencilset.url).replace("#", "%23");        	ORYX.Core.StencilSet.loadStencilSet(ORYX.CONFIG.STENCILSET_HANDLER + ssUrl, this.id);		} else {			var ssUrl = model.stencilset.url;        	ORYX.Core.StencilSet.loadStencilSet(ssUrl, this.id);		}		                //TODO load ealier and asynchronous??        this._loadStencilSetExtensionConfig();                //Load predefined StencilSetExtensions        if(!!ORYX.CONFIG.SSEXTS){        	ORYX.CONFIG.SSEXTS.each(function(ssext){                this.loadSSExtension(ssext.namespace);            }.bind(this));        }        //Create canvas        this._createCanvas(model.stencil ? model.stencil.id : null, model.properties);                // GENERATES the whole EXT.VIEWPORT        var isQuery = this.isQueryProcess(this.modelMetaData.name);        var queryJson = {};        var reqURI = this.modelMetaData.modelHandler;		var reqURIs = reqURI.split("/");		var prefix = "/";	    for(i=1; i<reqURIs.length-1; i++){		    prefix+=reqURIs[i]+"/";	    }        if(isQuery){		    var _generateGUI = this._generateGUI.bind(this);			//get query details		    Ext.Ajax.request({	   			url				: prefix+'query/',	   			method			: "GET",	   			timeout			: 1800000,	   			disableCaching	: true,	   			headers			: {'Accept':"application/json", 'Content-Type':'charset=UTF-8'},	   			params			: {									id: 'getInitQuery',									processID: this.modelMetaData.name.strip()					              },	   			success			: function(transport) {	   								queryJson = transport.responseText.evalJSON();	   								_generateGUI(isQuery, queryJson);								  },	   			failure			: function(transport) {	   								Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Query.initQueryFailure).setIcon(Ext.Msg.WARNING).getDialog().setWidth(260).center().syncSize();	   								_generateGUI(isQuery, {});								  }	   		});        }else{        	this._generateGUI(isQuery, {});        }						// Initializing of a callback to check loading ends		var loadPluginFinished 	= false;		var loadContentFinished = false;		var initFinished = function(){				if( !loadPluginFinished || !loadContentFinished ){ return }			this._finishedLoading(isQuery, queryJson, prefix);		}.bind(this)				// disable key events when Ext modal window is active		ORYX.Editor.makeExtModalWindowKeysave(this._getPluginFacade());				// LOAD the plugins		window.setTimeout(function(){			this.loadPlugins();			loadPluginFinished = true;			initFinished();		}.bind(this), 100);				// LOAD the content of the current editor instance (wait for 2 seconds)		window.setTimeout(function(){			// Check for querying process ... add by Nattawat			if(isQuery){				var loadSerialized = this.loadSerialized.bind(this);				var loadSerializedForQuery = this.loadSerializedForQuery.bind(this);				var getCanvas = this.getCanvas.bind(this);				if(queryJson!={} && queryJson.isInitiated == false){					// LOAD the content of query process					loadSerializedForQuery(model, true, queryJson); // Request the meta data as well		            getCanvas().update();					loadContentFinished = true;					initFinished();				}else{					// LOAD the content of the current editor instance		            loadSerialized(model, true); // Request the meta data as well		            getCanvas().update();					loadContentFinished = true;					initFinished();				}			}else{	            this.loadSerialized(model, true); // Request the meta data as well	            this.getCanvas().update();				loadContentFinished = true;				initFinished();			}		}.bind(this), 4000);	},		_finishedLoading: function(isQuery, queryJson, prefix) {		if(Ext.getCmp('oryx-loading-panel')){			Ext.getCmp('oryx-loading-panel').hide()		}				// Do Layout for viewport		this.layout.doLayout();		// Generate a drop target		new Ext.dd.DropTarget(this.getCanvas().rootNode.parentNode);				// Fixed the problem that the viewport can not 		// start with collapsed panels correctly		if (ORYX.CONFIG.PANEL_RIGHT_COLLAPSED === true){			this.layout_regions.east.collapse();		}		if (ORYX.CONFIG.PANEL_LEFT_COLLAPSED === true){			this.layout_regions.west.collapse();		}				// Raise Loaded Event		this.handleEvents( {type:ORYX.CONFIG.EVENT_LOADED} )				//get a referent/target process for query process    	//get SVG from Signavio file		//added by Nattawat		if(this.modelMetaData.model.stencilset.namespace == 'http://b3mn.org/stencilset/bpmn1.1#' ||				this.modelMetaData.model.stencilset.namespace == 'http://b3mn.org/stencilset/bpmn2.0#'){			//always collapse south panel			this.layout_regions.south.collapse();			if(isQuery){		    	Ext.Ajax.request({		   			url				: prefix+'query/',		   			method			: "GET",		   			timeout			: 1800000,		   			disableCaching	: true,		   			headers			: {'Accept':"application/json", 'Content-Type':'charset=UTF-8'},		   			params			: {										id: 'getSVG',										task: queryJson.targetTask.strip(),										processID: queryJson.targetProcess.strip(),										parent: this.modelMetaData.parent						              },		   			success			: function(transport) {		   								var svgTag = transport.responseText;		   								// Create a Template		   								var dataDefault = {svg:svgTag};		   						   		var dialogIn = new Ext.XTemplate(			   										'<div id="svg_recommendation_canvas" style="text-align: center; align: center; margin: 0 auto;">{svg}</div>'		   									);		   						   				   						   		var panel = new Ext.Panel({		   						   			id: 'svg_referent_panel',		   						   			autoScroll: true,		   						   			html: dialogIn.apply(dataDefault),		   						   			bodyStyle:    'background-color:#FFFFFE'		   						   		});		   						   		//remove old recommended process			   			        		var previousSVG = Ext.getCmp('recommendation_panel_child');			   			        		if(previousSVG){			   			        			Ext.getCmp('recommendation_panel').remove(previousSVG);			   			        		}		   						   		Ext.getCmp('recommendation_panel').add(panel);		   						   		Ext.getCmp('recommendation_panel').doLayout();									  },		   			failure			: function(transport) {									  }		   		});		    }else{		    	var modelMeta = this.modelMetaData;		    	var clickTreeListener = function (node,event){		    		if(node.isLeaf()){		    			Ext.getCmp('svg_query_process_panel').body.mask(ORYX.I18N.Query.pleaseWait, "x-waiting-box");			    		Ext.Ajax.request({				   			url				: prefix+'query/',				   			method			: "GET",				   			timeout			: 1800000,				   			disableCaching	: true,				   			headers			: {'Accept':"application/json", 'Content-Type':'charset=UTF-8'},				   			params			: {												id: 'getSVG',												processID: node.text,												task: node.attributes.targetTask,												parent: modelMeta.parent								              },				   			success			: function(transport) {				   								Ext.getCmp('svg_query_process_panel').body.unmask();				   							    //remove old query process					   							Ext.getCmp('recommendation_tab_panel').setActiveTab(0);					   			        		var previousSVG = Ext.getCmp('svg_query_process_div');					   			        		if(previousSVG){					   			        			Ext.getCmp('svg_query_process_panel').remove(previousSVG);					   			        		}					   			        		var dataDefault = {task: node.attributes.targetTask, processID: node.text, zone: node.attributes.zone, desc: node.attributes.desc};					   			        		var dialogIn;					   			        		if(dataDefault.desc != ""){					   			        			dialogIn = new Ext.XTemplate(							   			        			'<div>',								   			        			'<input type="hidden" id="tagetTaskInSvgQueryPanel" value="{task}"/>',							   			        				'<input type="hidden" id="queryProcessIdInSvgQueryPanel" value="{processID}"/>',							   			        				'<input type="hidden" id="zoneInSvgQueryPanel" value="{zone}"/>',										   						'<p id="query_details_box" style="display:none; padding:5px; margin:2px; color:#383838;">',										   							'{desc}<br/>',										   						'</p>',										   						'<div id="svg_query_canvas" style="display:none; text-align: left; align: left; margin: 0 auto; overflow:visible">' + transport.responseText + '</div>',									   						'</div>'										   				);					   			        		}else{					   			        			dialogIn = new Ext.XTemplate(							   			        			'<div>',								   			        			'<input type="hidden" id="tagetTaskInSvgQueryPanel" value="{task}"/>',							   			        				'<input type="hidden" id="queryProcessIdInSvgQueryPanel" value="{processID}"/>',							   			        				'<input type="hidden" id="zoneInSvgQueryPanel" value="{zone}"/>',										   						'<div id="svg_query_canvas" style="display:none; text-align: left; align: left; margin: 0 auto; overflow:visible">' + transport.responseText + '</div>',									   						'</div>'										   				);					   			        		}					   			        							   			        		var panel2 = new Ext.Panel({					   			        			id: 'svg_query_process_div',					   			        			border:false,//					   			        			autoScroll: true,					   			        			html: dialogIn.apply(dataDefault),					   			        			bodyStyle:    'background-color:#FFFFFE'					   			        		});					   			        							   			        		Ext.getCmp('recommendation_tab_panel').setActiveTab(0);					   			        		Ext.getCmp('svg_query_process_panel').add(panel2);					   			        		Ext.getCmp('svg_query_process_panel').doLayout();					   			        		if(Ext.get("query_details_box")){					   			        			Ext.get("query_details_box").slideIn('l', { duration: 1 });					   			        		}					   							Ext.get("svg_query_canvas").fadeIn({ endOpacity: 1, duration: 1});											  },				   			failure			: function(transport) {				   								Ext.getCmp('svg_query_process_panel').body.unmask();				   								Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Query.loadSVGQueryFailure).setIcon(Ext.Msg.WARNING).getDialog().setWidth(260).center().syncSize();											  }			    		});		    		}		    	};		    			    	var clickRefreshListener = function(){		    		Ext.getCmp('tree_query_process_panel').body.mask(ORYX.I18N.Query.pleaseWait, "x-waiting-box");		    		Ext.Ajax.request({			   			url				: prefix+'query/',			   			method			: "GET",			   			timeout			: 1800000,			   			disableCaching	: true,			   			headers			: {'Accept':"application/json", 'Content-Type':'charset=UTF-8'},			   			params			: {											id: 'getAllQueries',											processID: modelMeta.name							              },			   			success			: function(transport) {			   								Ext.getCmp('tree_query_process_panel').body.unmask();								   			Ext.getCmp('recommendation_tab_panel').setActiveTab(0);								   			var root = new Ext.tree.AsyncTreeNode({								   					expanded:true								 	               ,leaf:false								 	               ,text:'Queries'								 	               ,children:transport.responseText.evalJSON()								 	          	});								   		   // Remove all childs								   			var child = Ext.getCmp('tree_query_process_panel').getRootNode().firstChild;								   			while(child) {								   				Ext.getCmp('tree_query_process_panel').getRootNode().removeChild(child);								   				child = Ext.getCmp('tree_query_process_panel').getRootNode().firstChild;								   			}								   			if(transport.responseText.evalJSON().length>0){								   				Ext.getCmp('tree_query_process_panel').getRootNode().appendChild( root );									   			Ext.getCmp('tree_query_process_panel').render();									   			root.render();									   			root.expand(true);									       		root.collapse(true);									       		root.expand();								   			}										  },			   			failure			: function(transport) {			   								Ext.getCmp('tree_query_process_panel').body.unmask();			   								Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Query.loadQueryFailure).setIcon(Ext.Msg.WARNING).getDialog().setWidth(260).center().syncSize();										  }		    		});		    	};		    	var executeQuery = this.executeQuery.bind(this);		    	var clickExecuteListener = function(){		    		var queryProcessId = Ext.get('queryProcessIdInSvgQueryPanel');		    		if(queryProcessId){		    			Ext.Ajax.request({			 	   			url				: prefix+'query/',			 	   			method			: "GET",			 	   			timeout			: 1800000,			 	   			disableCaching	: true,			 	   			headers			: {'Accept':"application/json", 'Content-Type':'charset=UTF-8'},			 	   			params			: {			 									id: 'getJSON',			 									processID: queryProcessId.getValue(),			 									parent: modelMeta.parent			 					              },			 	   			success			: function(transport) {			 	   								executeQuery(prefix, transport.responseText.evalJSON());			 	   			},failure			: function(transport) {			 	   				Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Query.exception).setIcon(Ext.Msg.WARNING).getDialog().setWidth(260).center().syncSize();			 	   			}		        		});		        				    		}else{		    			Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Query.noSelectedQuery).setIcon(Ext.Msg.INFO).getDialog().setWidth(260).center().syncSize();		    		}		    	};		    			    	var clickEditListener = function(){		    		var queryProcessId = Ext.get('queryProcessIdInSvgQueryPanel');		    		if(queryProcessId){		    			var modelURL = location.href.substring(0, location.href.indexOf(location.search)) + '?id=' + modelMeta.parent +";"+ queryProcessId.getValue() +".signavio.xml";						window.open(modelURL);		    		}else{		    			Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Query.noSelectedQuery).setIcon(Ext.Msg.INFO).getDialog().setWidth(260).center().syncSize();		    		}		    	};		    			    	var clickDeleteListener = function(){		    		var queryProcessId = Ext.get('queryProcessIdInSvgQueryPanel');		    		if(queryProcessId){		    			Ext.Msg.confirm(ORYX.I18N.Query.deleteQueryTitle, ORYX.I18N.Query.deleteQueryMsg, function(btn, text){	    				    if (btn == 'yes'){	    				    	Ext.getCmp('svg_query_process_panel').body.mask(ORYX.I18N.Query.pleaseWait, "x-waiting-box");	    		    			Ext.Ajax.request({	    			 	   			url				: prefix+'query/',	    			 	   			method			: "DELETE",	    			 	   			timeout			: 1800000,	    			 	   			disableCaching	: true,	    			 	   			headers			: {'Accept':"application/json", 'Content-Type':'charset=UTF-8'},	    			 	   			params			: {	    			 									id: 'deleteQuery',	    			 									processID: queryProcessId.getValue(),	    			 									parent: modelMeta.parent	    			 					              },	    			 	   			success			: function(transport) {	    			 	   				Ext.getCmp('svg_query_process_panel').body.unmask();	    			 	   				//remove old query process	    	   							Ext.getCmp('recommendation_tab_panel').setActiveTab(0);	    	   			        		var previousSVG = Ext.getCmp('svg_query_process_div');	    	   			        		if(previousSVG){	    	   			        			Ext.getCmp('svg_query_process_panel').remove(previousSVG);	    	   			        		}	    	   			        		clickRefreshListener();	    			 	   			},failure			: function(transport) {	    			 	   				Ext.getCmp('svg_query_process_panel').body.unmask();	    			 	   				Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Query.exception).setIcon(Ext.Msg.WARNING).getDialog().setWidth(260).center().syncSize();	    			 	   			}	    		        		});	    				    } else {	    				    }		    			});		    		}else{		    			Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Query.noSelectedQuery).setIcon(Ext.Msg.INFO).getDialog().setWidth(260).center().syncSize();		    		}		    	};		    			    			    	Ext.Ajax.request({		   			url				: prefix+'query/',		   			method			: "GET",		   			timeout			: 1800000,		   			disableCaching	: true,		   			headers			: {'Accept':"application/json", 'Content-Type':'charset=UTF-8'},		   			params			: {										id: 'getAllQueries',										processID: this.modelMetaData.name						              },		   			success			: function(transport) {		   								//create tree node		   								var rootNode;		   								if(transport.responseText.evalJSON().length>0){		   									rootNode = new Ext.tree.AsyncTreeNode({							 	                   expanded:true,								 	               leaf:false,								 	               text:'Root queries',								 	               children: [{"expanded":true, "text":"Queries","leaf":false,"children":transport.responseText.evalJSON()}]								 	            });		   								}else{		   									rootNode = new Ext.tree.AsyncTreeNode({							 	                   expanded:true,								 	               leaf:false,								 	               text:'Root queries'								 	            });		   								}						   										   						   								//create tree							   			 var tree = new Ext.tree.TreePanel({							   				id: 'tree_query_process_panel',							 		    	loader: new Ext.tree.TreeLoader(),							 		    	rootVisible: false,							 				lines: false,							 				anchors: '0, -30',//							 		    	useArrows: true,//							 		        autoScroll: true,							 		        animate: true,//							 		        border: false,							 		        width: 300,							 		        minSize: 200,									        maxSize: 500,							 		        region	: 'west',							 	            root: rootNode,							 	            listeners: {								    	        click: {								    	            fn:clickTreeListener								    	        }								    	    },								    	    tbar:[{ text: 'Refresh', 								    	    		listeners: { click: clickRefreshListener}								    	    	}]							 	        });							   			var centerPanel = new Ext.Panel({							   				id: 'svg_query_process_panel',											region	: 'center',											collapsible: true,											split: true,											bodyStyle:    'background-color:#FFFFFE',											tbar:[{ text: 'Execute', 							    	    		listeners: { click: clickExecuteListener}							    	    	},{ text: 'Edit', 							    	    		listeners: { click: clickEditListener}							    	    	},{ text: 'Delete', 							    	    		listeners: { click: clickDeleteListener}							    	    	}]										});							   			var panel = new Ext.Panel({							   				layout:'border',										    defaults: {										        collapsible: true,										        split: true										    },//										    border:false,//										    autoScroll: true,										    width: 1500,										    height: 500,										    items: [tree, centerPanel]										});							   			Ext.getCmp('recommendation_tab_panel').setActiveTab(0);							       		Ext.getCmp('recommendation_input_panel').add(panel);							       		Ext.getCmp('recommendation_input_panel').doLayout();									  },		   			failure			: function(transport) {		   								Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Query.loadQueryFailure).setIcon(Ext.Msg.WARNING).getDialog().setWidth(260).center().syncSize();									  }		   		});		    }		}	},		//Act the same as query plugin ** COPY FROM query.js **	executeQuery: function(prefix, modelJSON){		var modelMeta = this.modelMetaData;		var reqURI = modelMeta.modelHandler;		var canvasChilds  = modelJSON.childShapes;		var tasks = [];		for(var i=0; i<canvasChilds.length; i++){		    if(canvasChilds[i].stencil.id == 'Task' || canvasChilds[i].stencil.id == 'CollapsedSubprocess'){		    	tasks.push(canvasChilds[i].properties.name);		    }	    }				var taskTxt = "[";		for(i=0; i<tasks.length; i++){			taskTxt+="['"+tasks[i].strip()+"', '"+tasks[i].strip()+"'],";	    }		taskTxt = taskTxt.substring(0,taskTxt.length-1)+"]";				// Create form		var methods = [		                [2, 'Levenstein']		               ,[4, 'Improved weight']		           ];		var formPanel = new Ext.form.FormPanel({			id		: 'query_model',			bodyStyle:'padding:10px',	        width	: 'auto',	        height	: 'auto',            items:[                      new Ext.form.ComboBox({                    	fieldLabel: ORYX.I18N.Query.targetTask,                    	name: 'task',                    	id: 'task',                    	store: new Ext.data.SimpleStore({   					    	fields:['myId', 'myText'],   					        data:eval(taskTxt)   					    })                     	,allowBlank:false                     	,autoWidth:true                     	,emptyText: '-- select --'   					    ,valueField:'myId'					    ,displayField:'myText'					    ,mode:'local'					    ,triggerAction: 'all'					    ,listeners:{					       'select': function(){					    	   formPanel.body.mask(ORYX.I18N.Query.pleaseWait, "x-waiting-box");			    	   			// get max zone					    	   	Ext.Ajax.request({						   			url				: prefix+'query/',						   			method			: "GET",						   			timeout			: 1800000,						   			disableCaching	: true,						   			headers			: {'Accept':"application/json", 'Content-Type':'charset=UTF-8'},						   			params			: {														id: 'getMaxZone',														task: this.getValue().strip(),														processID: Ext.get('queryProcessIdInSvgQueryPanel').getValue()										              },						   			success			: function(transport) {						   								formPanel.body.unmask();						   								var zoneJson = transport.responseText.evalJSON();						   								Ext.getCmp('zone').reset();						   								var zoneCmp = Ext.getCmp('zone');						   								var rt = Ext.data.Record.create([						   								    {name: 'myId'},						   								    {name: 'myText'}						   								]);						   								var zoneStore = new Ext.data.Store ({						   									isAutoLoad: true,						   								    reader: new Ext.data.JsonReader({						   								    	root: 'zone',							   								    fields: [							   								        {name: 'myId', mapping: 'myId'},							   								        {name: 'myText', mapping: 'myText'}							   								    ]},rt)						   								})						   								zoneStore.loadData(zoneJson);						   								zoneCmp.bindStore(zoneStore);													  },						   			failure			: function(transport) {						   									formPanel.body.unmask();											   				Ext.getCmp('zone').reset();							   								var zoneCmp = Ext.getCmp('zone');						   									var zoneStore = new Ext.data.SimpleStore({									   					    	fields:['myId', 'myText'],									   					        data:[['1','1'],['2','2'],['3','3'],['4','4'],['5','5']]									   					    })						   									zoneCmp.bindStore(zoneStore);													  }						   		})				    	   	}					    }                     }),                     new Ext.form.ComboBox({                    	fieldLabel: ORYX.I18N.Query.zone,                    	name: 'zone',                    	id: 'zone',                     	store: new Ext.data.SimpleStore({   					    	fields:['myId', 'myText'],   					        data:[]   					    })                     	,allowBlank:false                     	,emptyText: '-- select --'   					    ,valueField:'myId' 					    ,displayField:'myText' 					    ,mode:'local' 					    ,triggerAction: 'all'                      }),                      new Ext.form.ComboBox({                    	fieldLabel: ORYX.I18N.Query.method,                    	name: 'method',                    	id: 'method',   					    store: new Ext.data.SimpleStore({   					    	fields:['myId', 'myText'],   					        data:methods   					    })                      	,allowBlank:false                      	,emptyText: '-- select --'   					    ,valueField:'myId'   					    ,displayField:'myText'   					    ,mode:'local'   					    ,triggerAction: 'all'                      })            ] 		});				// Create new window and attach form into it		var win = new Ext.Window({	        id		: 'Query_Window',	        width	: 'auto',	        height	: 'auto',		    title	: ORYX.I18N.Query.queryDesc,	        modal	: true,	        resizable	: false,			bodyStyle: 'background:#FFFFFF',	        items  : [formPanel],            defaultButton: 0,				buttons:[{					text: ORYX.I18N.Query.queryBtn,					handler: function(){									win.body.mask(ORYX.I18N.Query.pleaseWait, "x-waiting-box");										window.setTimeout(function(){												callback(formPanel.getForm());											}.bind(this), 10);							},				listeners:{					render:function(){						this.focus();					}				}			},{	        	text: ORYX.I18N.Save.close,	        	handler: function(){	               win.close();	        	}.bind(this)			}],			listeners: {				close: function(){						            	win.destroy();					delete this.saving;				}.bind(this)			}  	    });				// Create the callback for the template		callback = function(form){			//remove results window			var previousResultsWin = Ext.getCmp('Query_Result_Window');       		if(previousResultsWin){       			Ext.getCmp('Query_Result_Window').destroy();       		}						var task = form.findField('task').getValue();			var zone = form.findField('zone').getValue();			var method = form.findField('method').getValue();			new Ajax.Request(prefix+'query/', {	            method: 'get',	            asynchronous: true,				requestHeaders: {					"Accept":"application/json"				},				parameters: {					id: 'getRecommendation',					task: task,					zone: zone,					method: method,					processID: Ext.get('queryProcessIdInSvgQueryPanel').getValue()	            },				encoding: 'UTF-8',				onSuccess: successQuery,				onException: function(){					Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Query.getFailure).setIcon(Ext.Msg.WARNING).getDialog().setWidth(260).center().syncSize();					win.close();				}.bind(this),				onFailure: (function(transport) {					Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Query.getFailure).setIcon(Ext.Msg.WARNING).getDialog().setWidth(260).center().syncSize();					win.close();				}).bind(this),				on401: (function(transport) {					Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Query.getFailure).setIcon(Ext.Msg.WARNING).getDialog().setWidth(260).center().syncSize();					win.close();				}).bind(this),				on403: (function(transport) {					Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Query.getFailure).setIcon(Ext.Msg.WARNING).getDialog().setWidth(260).center().syncSize();					win.close();				}).bind(this)			});					}.bind(this);				win.show();				//automatically select target task and zone of a selected query 		var taskCmp = Ext.getCmp('task');		taskCmp.setValue(Ext.get('tagetTaskInSvgQueryPanel').getValue());		taskCmp.fireEvent('select');				var showProcessImg = this.showProcessImg.bind(this);				var successQuery = function(transport) {			var resJSON = transport.responseText.evalJSON();			var rt = Ext.data.Record.create([			    {name: 'comparedTask'},			    {name: 'comparedProcessID'},			    {name: 'matchingValue'}			])			var resultStore = new Ext.data.Store ({				isAutoLoad: true,			    reader: new Ext.data.JsonReader({			    	root: 'results',				    fields: [				        {name: 'comparedTask', mapping: 'comparedTask'},				        {name: 'comparedProcessID', mapping: 'comparedProcessID'},				        {name: 'matchingValue', mapping: 'matchingValue'}				    ]},rt)			})						resultStore.loadData(resJSON);						var grid = new Ext.grid.GridPanel({				id:	'grid_results',			    store: resultStore,			    autoScroll: true,			    colModel: new Ext.grid.ColumnModel({			    	defaultSortable: true,			    	defaults: {			            sortable: true			        },			        columns: [			            {id: 'similarTask', width: 10, header: 'Similar tasks', dataIndex: 'comparedTask', type:'string', 			            	renderer: function(value, metaData, record, rowIndex, colIndex, store, view) {//			            		metaData.attr = 'ext:qtip="' + value + '"';			            		return value;			            	}			            },			            {id: 'processID', width: 10, header: 'ProcessID', dataIndex: 'comparedProcessID', type:'string'},			            {id: 'similarValue', width: 10, header: 'Similarity value', dataIndex: 'matchingValue', type:'float'},		            ]			    }),			    viewConfig: {			        forceFit: true,			    },			    sm: new Ext.grid.RowSelectionModel({	                singleSelect: true,	                listeners: {	                     rowselect: showProcessImg	               }	            }),			    width: 800,			    height: 400,			    frame: true,			    layout: 'fit',			    iconCls: 'icon-grid'			});						var defaultData1 = {processID:resJSON.processID, taskName:resJSON.task, zone:resJSON.zone, method:resJSON.method}				// Create a Template			var dialog1 = new Ext.XTemplate(							'<div style="height: 370px; width:250; background-color: #F0F0F0;">',						'<p id="details_box1" style="display:none; padding:5px; margin:2px; color:#383838;">',							'Task : {taskName} <br/>',							'Process : {processID} <br/>',							'Zone : {zone} <br/>',							'Method : {method} <br/>',						'</p>',						'<input type="hidden" id="input_query_task" value="{taskName}"/>',						'<input type="hidden" id="input_query_process" value="{processID}"/>',						'<input type="hidden" id="input_query_zone" value="{zone}"/>',						'<input type="hidden" id="input_query_method" value="{method}"/>',					'</div>'			)			var panel = new Ext.Panel({			    layout:'border',			    defaults: {			        collapsible: true,			        split: true			    },			    width: 800,			    height: 400,			    items: [{			        title: ORYX.I18N.Query.queryDetailsDesc,			        collapseTitle : ORYX.I18N.Query.queryDetailsDesc,			        region:'west',			        margins: '5 0 0 0',			        cmargins: '5 5 0 0',			        width: 175,			        minSize: 100,			        maxSize: 250,			        html: dialog1.apply(defaultData1)			    },{			    	collapsible: false,			        region:'center',			        margins: '5 0 0 0',			        items: [grid]			    }]			});						// Create new window and attach grid results into it			var winResults = new Ext.Window({				id		: 'Query_Result_Window',		        width	: 'auto',		        height	: 'auto',			    title	: ORYX.I18N.Query.queryResultsDesc,		        modal	: true,		        resizable	: false,				bodyStyle: 'background:#FFFFFF',		        items  : [panel],	            defaultButton: 0,		        buttons:[{	            	text: ORYX.I18N.Save.close,	            	handler: function(){	            		winResults.close();	            	}.bind(this)				}],				listeners: {					close: function(){											winResults.destroy();						delete this.saving;					}.bind(this)				}		    });			win.close();			winResults.show();			Ext.get("grid_results").fadeIn({ endOpacity: 1, duration: 1});			Ext.get("details_box1").fadeIn({ endOpacity: 1, duration: 1});		}.bind(this);	},		//View SVG process when it is selected from similar process in grid ** COPY FROM query.js **	showProcessImg: function(smObj, rowIndex, record) {		//bind global object to be local one		var modelMeta = this.modelMetaData;		var reqURI = modelMeta.modelHandler;		var reqURIs = reqURI.split("/");		var prefix = "/";	    for(i=1; i<reqURIs.length-1; i++){		    prefix+=reqURIs[i]+"/";	    }		var createInteractiveSVG = this.createInteractiveSVG.bind(this);		var facadeObj = this;				Ext.WindowMgr.get('Query_Result_Window').body.mask(ORYX.I18N.Query.pleaseWait, "x-waiting-box");				//get SVG from Signavio file		Ext.Ajax.request({   			url				: prefix+'query/',   			method			: "GET",   			timeout			: 1800000,   			disableCaching	: true,   			headers			: {'Accept':"application/json", 'Content-Type':'charset=UTF-8'},   			params			: {								id: 'getSVG',								task: record.get('comparedTask').strip(),								processID: record.get('comparedProcessID').strip(),								parent: modelMeta.parent				              },   			success			: function(transport) {   				var SVGTag = transport.responseText;					//input panel   				var defaultDataInput = {taskName:Ext.get('input_query_task').getValue(),   							processID:Ext.get('input_query_process').getValue(),	   						zone:Ext.get('input_query_zone').getValue(),	   						method:Ext.get('input_query_method').getValue()   						};   				//get input SVG   				Ext.Ajax.request({   		   			url				: prefix+'query/',   		   			method			: "GET",   		   			timeout			: 1800000,   		   			disableCaching	: true,   		   			headers			: {'Accept':"application/json", 'Content-Type':'charset=UTF-8'},   		   			params			: {   										id: 'getSVG',   										task: defaultDataInput.taskName.strip(),   										processID: defaultDataInput.processID.strip(),   										parent: modelMeta.parent   						              },   		   			success			: function(transport) {					   		   			Ext.WindowMgr.get('Query_Result_Window').body.unmask();						   				Ext.WindowMgr.get('Query_Result_Window').hide();						   										   				//input panel						   				// Create a Template						   				var dialogInput = new Ext.XTemplate(							   						'<div style="width: 900px; height: 250px; overflow:scroll;">',							   						'<p id="input_details_box2" style="display:none; border-style:solid; border-width:1px; padding:5px; margin:2px; position:absolute; top:3px; left:10px; border-color: #C3C3C3; background-color: #F0F0F0; color:#383838;">',							   							'<b>Query process</b><br/>',								   							'Task : {taskName} <br/>',							   							'Process : {processID} <br/>',							   							'Zone : {zone} <br/>',							   							'Method : {method} <br/>',							   						'</p>',							   						'<div id="svg_input_box" style="display:none; text-align: center">' + transport.responseText + '</div>',						   						'</div>'						   				)						   										   				//output panel 						   				var defaultDataOutput = {processID:record.get('comparedProcessID').strip(), taskName:record.get('comparedTask').strip(), simValue:record.get('matchingValue') }						   				// Create a Template						   				var dialogOutput = new Ext.XTemplate(							   						'<div style="width: 900px; height: 250px; overflow:scroll;">',							   						'<p id="details_box2" style="display:none; border-style:solid; border-width:1px; padding:5px; margin:2px; position:absolute; top:3px; left:10px; border-color: #C3C3C3; background-color: #F0F0F0; color:#383838;">',							   							'<b>Similar process</b><br/>',							   							'Task : {taskName} <br/>',							   							'Process : {processID} <br/>',							   							'Sim. value : {simValue} <br/>',							   						'</p>',							   						'<div id="svg_box" style="display:none; text-align: center">' + SVGTag + '</div>',						   						'</div>'						   				)						   				var panel = new Ext.Panel({						   					type: 'vbox',						   					align : 'stretch',										    width: 'auto',										    height: 'auto',										    items: [{										        margins: '5 0 0 0',										        html: dialogInput.apply(defaultDataInput)										    },{										        margins: '5 0 0 0',										        html: dialogOutput.apply(defaultDataOutput)										    }]										});						   				// Create new window and SVG tag into it						   				var winSVG = new Ext.Window({						   			        id		: 'svg_Window',						   			        width	: 'auto',						   			        height	: 'auto',						   				    title	: ORYX.I18N.Query.queryResultsSVGDesc,				//		   				    maximizable: true,						   			        modal	: true,						   			        resizable	: false,						   					bodyStyle: 'background:#FFFFFF',						   					frame: true,						   					items: [panel],						   		            defaultButton: 0,						   						buttons:[{							   			        	text: ORYX.I18N.Query.copyAllBtn,							   			        	handler: function(){							   			        		winSVG.body.mask(ORYX.I18N.Query.pleaseWait, "x-waiting-box");							   			        		Ext.Ajax.request({								   			 	   			url				: prefix+'query/',								   			 	   			method			: "GET",								   			 	   			timeout			: 1800000,								   			 	   			disableCaching	: true,								   			 	   			headers			: {'Accept':"application/json", 'Content-Type':'charset=UTF-8'},								   			 	   			params			: {								   			 									id: 'getJSON',								   			 									task: record.get('comparedTask').strip(),								   			 									processID: record.get('comparedProcessID').strip(),								   			 									parent: modelMeta.parent								   			 					              },								   			 	   			success			: function(transport) {													   			 	   			winSVG.close();													   			        															   			        		//remove old recommended process													   			 	   			Ext.getCmp('recommendation_tab_panel').setActiveTab(1);													   			        		var previousSVG = Ext.getCmp('svg_recommendation_panel');													   			        		if(previousSVG){													   			        			Ext.getCmp('recommendation_output_panel').remove(previousSVG);													   			        		}													   			        															   			        		Ext.getCmp('recommendation_panel').collapse(true);													   			        															   			        		facadeObj.importJSON(transport.responseText.evalJSON());								   			 	   			},failure			: function(transport) {								   			 	   				winSVG.close();								   			 	   				Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Query.exception+' "'+record.get('comparedProcessID').strip()+'"').setIcon(Ext.Msg.WARNING).getDialog().setWidth(260).center().syncSize();															}							   			        		})							   			        	}.bind(this)							   					},{							   			        	text: ORYX.I18N.Query.selectBtn,							   			        	handler: function(){							   			        		createInteractiveSVG(record.get('comparedTask').strip(), record.get('comparedProcessID').strip());							   			        	}.bind(this)							   					},{							   						text: ORYX.I18N.Query.backBtn,							   						handler: function(){							   							winSVG.close();							   							Ext.WindowMgr.get('Query_Result_Window').show();							   							Ext.getCmp("grid_results").getSelectionModel().deselectRow(rowIndex);							   							Ext.get("grid_results").fadeIn({ endOpacity: 1, duration: 1});							   							Ext.get("details_box1").fadeIn({ endOpacity: 1, duration: 1});							   						},							   						listeners:{							   							render:function(){							   								this.focus();							   							}							   						}							   					},{							   			        	text: ORYX.I18N.Save.close,							   			        	handler: function(){							   			        		winSVG.close();							   			        	}.bind(this)							   					}],						   					listeners: {						   						close: function(){											   							winSVG.destroy();						   							delete this.saving;						   						}.bind(this)						   					}  						   			    });						   				winSVG.show();						   				Ext.get("svg_input_box").fadeIn({ endOpacity: 1, duration: 1});						   				Ext.get("input_details_box2").slideIn('l', { duration: 1 });						   				Ext.get("svg_box").fadeIn({ endOpacity: 1, duration: 1});						   				Ext.get("details_box2").slideIn('l', { duration: 1 });				   		   			},failure			: function(transport) {											Ext.WindowMgr.get('Query_Result_Window').body.unmask();											Ext.WindowMgr.get('Query_Result_Window').hide();											Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Query.getSVGFailure+' "'+record.get('comparedProcessID').strip()+'"').setIcon(Ext.Msg.WARNING).getDialog().setWidth(260).center().syncSize();											Ext.WindowMgr.get('Query_Result_Window').show();									  }				   					});							  },   			failure			: function(transport) {   								Ext.WindowMgr.get('Query_Result_Window').body.unmask();   								Ext.WindowMgr.get('Query_Result_Window').hide();   								Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Query.getSVGFailure+' "'+record.get('comparedProcessID').strip()+'"').setIcon(Ext.Msg.WARNING).getDialog().setWidth(260).center().syncSize();   								Ext.WindowMgr.get('Query_Result_Window').show();							  }   		})	},		//create interactive SVG from a ordinary one ** COPY FROM query.js **	createInteractiveSVG: function(task, processID){		//bind global object to be local one		var modelMeta = this.modelMetaData;		var reqURI = modelMeta.modelHandler;		var reqURIs = reqURI.split("/");		var prefix = "/";	    for(i=1; i<reqURIs.length-1; i++){		    prefix+=reqURIs[i]+"/";	    }		var clone = this.clone.bind(this);		var facadeObj = this;				Ext.WindowMgr.get('svg_Window').body.mask(ORYX.I18N.Query.pleaseWait, "x-waiting-box");		Ext.Ajax.request({	   			url				: prefix+'query/',	   			method			: "GET",	   			timeout			: 1800000,	   			disableCaching	: true,	   			headers			: {'Accept':"application/json", 'Content-Type':'charset=UTF-8'},	   			params			: {									id: 'getInteractiveSVG',									task: task,									processID: processID,									parent: modelMeta.parent					              },	   			success			: function(transport) {	   							Ext.WindowMgr.get('svg_Window').close();	   			        			   			        		//remove old recommended process	   							Ext.getCmp('recommendation_tab_panel').setActiveTab(1);	   			        		var previousSVG = Ext.getCmp('svg_recommendation_panel');	   			        		if(previousSVG){	   			        			Ext.getCmp('recommendation_tab_panel').getItem('recommendation_output_panel').remove(previousSVG);	   			        		}	   			        		var dataDefault = {task: task, processID: processID};	   			        		var dialogIn = new Ext.XTemplate(		   			        			'<div>',	   			        				'<input type="hidden" id="selectedSVGCmp" value=""/>',	   			        				'<input type="hidden" id="tagetTaskInSvgRecommendationPanel" value="{task}"/>',	   			        				'<input type="hidden" id="tagetProcessIdInSvgRecommendationPanel" value="{processID}"/>',	   			        			'</div>',					   				'<div id="svg_recommendation_canvas" style="text-align: center; align: center; margin: 0 auto;">' + transport.responseText + '</div>'				   				)	   			        		var panel2 = new Ext.Panel({	   			        			id: 'svg_recommendation_panel',	   			        			autoScroll: true,	   			        			border	:false,	   			        			html: dialogIn.apply(dataDefault),	   			        			bodyStyle:    'background-color:#FFFFFE'	   			        		});	   			        			   			        		Ext.getCmp('recommendation_tab_panel').setActiveTab(1);	   			        		Ext.getCmp('recommendation_panel').collapse(false);	   			        		Ext.getCmp('recommendation_output_panel').add(panel2);	   			        		Ext.getCmp('recommendation_output_panel').doLayout();	   			        		Ext.getCmp('recommendation_panel').expand(true);	   			        			   			},failure			: function(transport) {	   				Ext.WindowMgr.get('svg_Window').close();	   				Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Query.exception+' "'+record.get('comparedProcessID').strip()+'"').setIcon(Ext.Msg.WARNING).getDialog().setWidth(260).center().syncSize();			}   		})	},		clone: function(obj) {	    if (null == obj || "object" != typeof obj) return obj;	    var copy = obj.constructor();	    for (var attr in obj) {	        if (obj.hasOwnProperty(attr)) copy[attr] = obj[attr];	    }	    return copy;	},		_initEventListener: function(){		// Register on Events				document.documentElement.addEventListener(ORYX.CONFIG.EVENT_KEYDOWN, this.catchKeyDownEvents.bind(this), false);		document.documentElement.addEventListener(ORYX.CONFIG.EVENT_KEYUP, this.catchKeyUpEvents.bind(this), false);		// Enable Key up and down Event		this._keydownEnabled = 	true;		this._keyupEnabled =  	true;		this.DOMEventListeners[ORYX.CONFIG.EVENT_MOUSEDOWN] = [];		this.DOMEventListeners[ORYX.CONFIG.EVENT_MOUSEUP] 	= [];		this.DOMEventListeners[ORYX.CONFIG.EVENT_MOUSEOVER] = [];		this.DOMEventListeners[ORYX.CONFIG.EVENT_MOUSEOUT] 	= [];		this.DOMEventListeners[ORYX.CONFIG.EVENT_SELECTION_CHANGED] = [];		this.DOMEventListeners[ORYX.CONFIG.EVENT_MOUSEMOVE] = [];					},		/**	 *	get selected components in south canvas	 */	extractSelectedSVGFromJSON: function(jsonProcess, selectedIDs){		var noOfChild = 0;		noOfChild = jsonProcess.childShapes.length;		var deleteIds = [];		//find unselected components   		for(var i=0; i<noOfChild; i++){   			var exist = false;   			//loop only length-1 bz, the last cmp is empty       		for(var j=0; j<selectedIDs.length-1; j++){       			if(selectedIDs[j].substring(4,selectedIDs[j].length) == jsonProcess.childShapes[i].resourceId){       				exist = true;       				break;       			}       		}       		if(!exist){       			deleteIds.push(jsonProcess.childShapes[i].resourceId);       		}   		}   		//remove unselected components   		for(var i=0; i<deleteIds.length; i++){   			for(var j=0; j<jsonProcess.childShapes.length; j++){   				if(jsonProcess.childShapes[j].resourceId == deleteIds[i]){   					jsonProcess.childShapes.splice(j,1);   					break;   				}   			}   		}	},		/**	 *	Correct partial SVG, used when copy partial process into canvas (from south panel)	 */	verifyPartialSVG: function(jsonProcess){   		for(var i=0; i<jsonProcess.childShapes.length; i++){   			for(var j=0; j<jsonProcess.childShapes[i].outgoing.length; j++){				var resourceId = jsonProcess.childShapes[i].outgoing[j].resourceId;				//check that is there any reference for this resourceId				var exist = false;				for(var k=0; k<jsonProcess.childShapes.length; k++){					if(jsonProcess.childShapes[k].resourceId == resourceId){						exist = true;						break;					}				}				if(!exist){					jsonProcess.childShapes[i].outgoing.splice(j,1);				}			}   			if(jsonProcess.childShapes[i].stencil.id == 'SequenceFlow'){   				//	for sequence, we have to check target as well   				var targetId = jsonProcess.childShapes[i].target.resourceId;   				//check that is there any referrence for this target resourceId				var exist = false;				for(var k=0; k<jsonProcess.childShapes.length; k++){					if(jsonProcess.childShapes[k].resourceId == targetId){						exist = true;						break;					}				}				if(!exist){					jsonProcess.childShapes[i].target = null;				}   			}    	}	},		/**     * Check file name format whether it follow query process format     * ex/ name.query.queryNo     * */    isQueryProcess: function(processId){    	if(processId!=""){    		var nameFragments = processId.split(".");        	if(nameFragments.length>1 && nameFragments[1] == 'query'){        		return true;        	}else{        		return false;        	}    	}else{    		return false;    	}    	    },    	/**	 * create south panel .. normal and query process have different south panel	 * added by Nattawat Nonsung	 * */	createSouthPanel: function(){		var modelMeta = this.modelMetaData;		var reqURI = modelMeta.modelHandler;		var reqURIs = reqURI.split("/");		var prefix = "/";	    for(i=1; i<reqURIs.length-1; i++){		    prefix+=reqURIs[i]+"/";	    }	    var facadeObj = this;	    var extractSelectedSVGFromJSON = this.extractSelectedSVGFromJSON.bind(this);	    var verifyPartialSVG = this.verifyPartialSVG.bind(this);	    var southPanel = new Ext.TabPanel({				id: 'recommendation_tab_panel',			    activeTab: 0,			    items: [{			    	id : 'recommendation_input_panel',			        title: ORYX.I18N.Query.inputTabDesc,			        autoScroll: true,			    },{			    	id : 'recommendation_output_panel',			        title: ORYX.I18N.Query.outputTabDesc,			        autoScroll: true,			        bodyStyle:    'background-color:#FFFFFE',			        defaultButton: 0,						buttons:[{								text: ORYX.I18N.Query.copyAllBtn,	   			        	handler: function(){	   			        		var previousSVG = Ext.getCmp('svg_recommendation_panel');	   			        		if(previousSVG){		   			        		Ext.getBody().mask(ORYX.I18N.Query.pleaseWait, "x-waiting-box");		   			        		Ext.getCmp('recommendation_panel').collapse(true);					        		Ext.Ajax.request({						 	   			url				: prefix+'query/',						 	   			method			: "GET",						 	   			timeout			: 1800000,						 	   			disableCaching	: true,						 	   			headers			: {'Accept':"application/json", 'Content-Type':'charset=UTF-8'},						 	   			params			: {						 									id: 'getJSON',						 									task: Ext.get('tagetTaskInSvgRecommendationPanel').getValue(),						 									processID: Ext.get('tagetProcessIdInSvgRecommendationPanel').getValue(),						 									parent: modelMeta.parent						 					              },						 	   			success			: function(transport) {									 	   				//remove old recommended process							   			        		Ext.getCmp('recommendation_tab_panel').setActiveTab(1);							   			        		var previousSVG = Ext.getCmp('svg_recommendation_panel');							   			        		if(previousSVG){							   			        			Ext.getCmp('recommendation_output_panel').remove(previousSVG);							   			        		}						 	   							facadeObj.importJSON(transport.responseText.evalJSON());						 	   							Ext.getBody().unmask();						 	   			},failure			: function(transport) {						 	   				Ext.getBody().unmask();						 	   				Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Query.exception).setIcon(Ext.Msg.WARNING).getDialog().setWidth(260).center().syncSize();						 	   			}					        		})	   			        		}	   			        	}.bind(this)						},{							text: ORYX.I18N.Query.copyCmpBtn,				        	handler: function(){				        		var previousSVG = Ext.getCmp('svg_recommendation_panel');	   			        		if(previousSVG){					        		Ext.getBody().mask(ORYX.I18N.Query.pleaseWait, "x-waiting-box");					        		Ext.Ajax.request({						 	   			url				: prefix+'query/',						 	   			method			: "GET",						 	   			timeout			: 1800000,						 	   			disableCaching	: true,						 	   			headers			: {'Accept':"application/json", 'Content-Type':'charset=UTF-8'},						 	   			params			: {						 									id: 'getJSON',						 									task: Ext.get('tagetTaskInSvgRecommendationPanel').getValue(),						 									processID: Ext.get('tagetProcessIdInSvgRecommendationPanel').getValue(),						 									parent: modelMeta.parent						 					              },						 	   			success			: function(transport) {						 	   							var selectedIDs = Ext.get('selectedSVGCmp').getValue().split(',');						 	   							var processJson = transport.responseText.evalJSON();							 	   						extractSelectedSVGFromJSON(processJson,selectedIDs);							   			        		verifyPartialSVG(processJson);							   			        		facadeObj.importJSON(processJson);							   			        		Ext.getCmp('recommendation_panel').collapse(true);						 	   							Ext.getBody().unmask();						 	   			},failure			: function(transport) {						 	   				Ext.getBody().unmask();						 	   				Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Query.exception+' "'+record.get('comparedProcessID').strip()+'"').setIcon(Ext.Msg.WARNING).getDialog().setWidth(260).center().syncSize();						 	   			}					        		})	   			        		}				        	}.bind(this)						}]			    }]			});				return southPanel;	},		/**	 * Generate the whole viewport of the	 * Editor and initialized the Ext-Framework	 * 	 */	_generateGUI: function(isQuery, queryJson) {		//TODO make the height be read from eRDF data from the canvas.		// default, a non-fullscreen editor shall define its height by layout.setHeight(int) 				// Defines the layout hight if it's NOT fullscreen		var layoutHeight 	= ORYX.CONFIG.WINDOW_HEIGHT;			var canvasParent	= this.getCanvas().rootNode.parentNode;		/**		 * Extend the Region implementation so that, 		 * the clicking area can be extend to the whole collapse area and		 * an title can now be shown.		 *		 */		var oldGetCollapsedEl = Ext.layout.BorderLayout.Region.prototype.getCollapsedEl;		Ext.layout.BorderLayout.Region.prototype.getCollapsedEl = function(){			oldGetCollapsedEl.apply(this, arguments);						if(this.collapseMode !== 'mini' && this.floatable === false && this.expandTriggerAll === true){               this.collapsedEl.addClassOnOver("x-layout-collapsed-over");			   this.collapsedEl.on("mouseover", this.collapsedEl.addClass.bind(this.collapsedEl, "x-layout-collapsed-over"));               this.collapsedEl.on("click", this.onExpandClick, this);            }						if (this.collapseTitle){				/* // Use CSS3 Attribute				this.collapsedEl.createChild({                    cls: "x-collapse-text", html: this.collapseTitle                });*/								// Use SVG to rotate text				var svg = ORYX.Editor.graft("http://www.w3.org/2000/svg", this.collapsedEl.dom,				['svg', {style:"position:relative;left:"+(this.position === "west" ? 4 : 6)+"px;top:"+(this.position === "west" ? 2 : 5)+"px;"},					['text', {transform:"rotate(90)", x:0, y:0, "stroke-width":"0px", fill:"#EEEEEE", style:"font-weight:bold;", "font-size":"11"}, this.collapseTitle]				]);				var text = svg.childNodes[0];				svg.setAttribute("xmlns:svg", "http://www.w3.org/2000/svg");								// Rotate the west into the other side				if (this.position === "west" && text.getComputedTextLength instanceof Function){					// Wait till rendered					window.setTimeout(function(){						var length  = text.getComputedTextLength();						text.setAttributeNS(null, "transform", "rotate(-90, " + ((length / 2) + 7) + ", " + ((length / 2) - 3) + ")");;					}, 1)				}				delete this.collapseTitle;			}	        return this.collapsedEl;		}				//For south canvas ... added by Nattawat		var southTabPanel;		var southPanelDesc = "";		var sounthPanel;		if(this.modelMetaData.model.stencilset.namespace == 'http://b3mn.org/stencilset/bpmn1.1#' ||				this.modelMetaData.model.stencilset.namespace == 'http://b3mn.org/stencilset/bpmn2.0#'){			if(isQuery){				southTabPanel = new Ext.Panel({					id: "recommendation_panel_child",		   			autoScroll: true,		   			bodyStyle:    'background-color:#FFFFFE'		   		});				southPanelDesc = ORYX.I18N.View.SouthQuery;			}else{				southTabPanel = this.createSouthPanel();				southPanelDesc = ORYX.I18N.View.South;			}			sounthPanel = new Ext.Panel({				id : 'recommendation_panel',				region	: 'south',				layout	: 'fit',				autoEl	: 'div',				collapseTitle : southPanelDesc,				cls		: 'x-panel-editor-south',				margins: '5 0 0 0',		        cmargins: '5 5 0 0',		        height : 300,		        minSize: 100,		        maxSize: 500,		        border	:false,//		        autoScroll:true,				cmargins: {left:0, right:0},				floatable: false,		        collapsible: true,		        split: true,		        title	:  southPanelDesc,		        items	: [southTabPanel]			});		}else{			sounthPanel = new Ext.Panel({				region  : 'south',                cls     : 'x-panel-editor-south',                autoEl  : 'div',                border  : false			});		}				// DEFINITION OF THE VIEWPORT AREAS		this.layout_regions = {								// DEFINES TOP-AREA				north	: new Ext.Panel({ //TOOO make a composite of the oryx header and addable elements (for toolbar), second one should contain margins					region	: 'north',					cls		: 'x-panel-editor-north',					autoEl	: 'div',					border	: false				}),									// DEFINES RIGHT-AREA				east	: new Ext.Panel({					region	: 'east',					layout	: 'fit',					cls		: 'x-panel-editor-east',					/*layout: 'accordion',					layoutConfig: {		               // layout-specific configs go here						titleCollapse: true,						animate: true,						activeOnTop: true	                },*/					autoEl	: 'div',					collapseTitle : ORYX.I18N.View.East,					border	:false,					cmargins: {left:0, right:0},					floatable: false,					expandTriggerAll:true,					collapsible	: true,					width	: ORYX.CONFIG.PANEL_RIGHT_WIDTH || 200,					split	: true,					title	: "East"				}),								// DEFINES BOTTOM-AREA				south	: sounthPanel,												// DEFINES LEFT-AREA				west	: new Ext.Panel({					region	: 'west',					layout	: 'anchor',					autoEl	: 'div',					cls		: 'x-panel-editor-west',					collapsible	: true,					collapseTitle : ORYX.I18N.View.West,					width	: ORYX.CONFIG.PANEL_LEFT_WIDTH || 200,					autoScroll:true,					cmargins: {left:0, right:0},					floatable: false,					expandTriggerAll:true,					split	: true,					title	: "West"				}),												// DEFINES CENTER-AREA (FOR THE EDITOR)				center	: new Ext.Panel({					region	: 'center',					cls		: 'x-panel-editor-center',					autoScroll: true,					items	: {						layout	: "fit",						autoHeight: true,						el		: canvasParent					}				})		}						// Hide every region except the center		for (region in this.layout_regions) {			if ( region != "center" ) {				//this.layout_regions[ region ].hide();			}		}				// Config for the Ext.Viewport 		var layout_config = {			layout: 'border',			items: [				this.layout_regions.north,				this.layout_regions.east,				this.layout_regions.south,				this.layout_regions.west,				this.layout_regions.center			]		}		// IF Fullscreen, use a viewport		if (this.fullscreen) {			this.layout = new Ext.Viewport( layout_config )				// IF NOT, use a panel and render it to the given id		} else {			layout_config.renderTo 	= this.id;			layout_config.height 	= layoutHeight;			this.layout = new Ext.Panel( layout_config )		}				//Generates the ORYX-Header		this._generateHeader();						// Set the editor to the center, and refresh the size	 	canvasParent.parentNode.setAttributeNS(null, 'align', 'center');	 	canvasParent.setAttributeNS(null, 'align', 'left');		this.getCanvas().setSize({			width	: ORYX.CONFIG.CANVAS_WIDTH,			height	: ORYX.CONFIG.CANVAS_HEIGHT		});									},		_generateHeader: function(){				var headerPanel = new Ext.Panel({			height		: 30,			autoHeight	: false,			border		: false,			html		: "<div id='oryx_editor_header'><a href=\""+ORYX.CONFIG.WEB_URL+"\" target=\"_blank\"><img src='"+ORYX.PATH+"images/oryx.small.gif' border=\"0\" /></a><div style='clear: both;'></div></div>" 		});		var maActive 	= ORYX.MashupAPI && ORYX.MashupAPI.isUsed;		var maKey		= maActive ? ORYX.MashupAPI.key : "";		var maCanRun	= maActive ? ORYX.MashupAPI.canRun : false;			var maIsRemoteM	= maActive ? ORYX.MashupAPI.isModelRemote : true;					var maModelImage= maIsRemoteM ? "<img src='"+ORYX.PATH+"images/page_white_put.png'/>" : "";		var maModelAuthI= maActive ? "<span class='mashupinfo'><img src='"+ORYX.PATH+"images/" +( maCanRun ? "plugin_error" : "plugin") +".png'/>" + maModelImage + "</span>" : "";						// Callback if the user changes		var fn = function(val){						var publicText = ORYX.I18N.Oryx.notLoggedOn;			var user = val && val.identifier && val.identifier != "public" ? decodeURI(val.identifier.gsub('"', "")).replace(/\+/g," ") : "";						if( user.length <= 0 ){				user 	= 	publicText;			}						var content = 	"<div id='oryx_editor_header'>" +								"<a href=\""+ORYX.CONFIG.WEB_URL+"\" target=\"_blank\">" +									"<img src='"+ORYX.PATH+"images/oryx.small.gif' border=\"0\" />" + 								"</a>" + 								"<span class='openid " + (publicText == user ? "not" : "") + "'>" + 									(unescape(user)) + 									maModelAuthI + 								"</span>" + 								"<div style='clear: both;'/>" + 							"</div>";						if( headerPanel.body ){				headerPanel.body.dom.innerHTML = content;			} else {				headerPanel.html = content			}		};					ORYX.Editor.Cookie.onChange(fn);		fn(ORYX.Editor.Cookie.getParams());				// The oryx header		this.addToRegion("north", headerPanel );	},		/**	 * adds a component to the specified region	 * 	 * @param {String} region	 * @param {Ext.Component} component	 * @param {String} title, optional	 * @return {Ext.Component} dom reference to the current region or null if specified region is unknown	 */	addToRegion: function(region, component, title) {				if (region.toLowerCase && this.layout_regions[region.toLowerCase()]) {			var current_region = this.layout_regions[region.toLowerCase()];			current_region.add(component);			/*if( (region.toLowerCase() == 'east' || region.toLowerCase() == 'west') && current_region.items.length == 2){ //!current_region.getLayout() instanceof Ext.layout.Accordion ){				var layout = new Ext.layout.Accordion( current_region.layoutConfig );            	current_region.setLayout( layout );								var items = current_region.items.clone();								current_region.items.each(function(item){ current_region.remove( item )})				items.each(function(item){ current_region.add( item )})							}	*/					ORYX.Log.debug("original dimensions of region %0: %1 x %2", current_region.region, current_region.width, current_region.height)			// update dimensions of region if required.			if  (!current_region.width && component.initialConfig && component.initialConfig.width) {				ORYX.Log.debug("resizing width of region %0: %1", current_region.region, component.initialConfig.width)					current_region.setWidth(component.initialConfig.width)			}			if  (component.initialConfig && component.initialConfig.height) {				ORYX.Log.debug("resizing height of region %0: %1", current_region.region, component.initialConfig.height)				var current_height = current_region.height || 0;				current_region.height = component.initialConfig.height + current_height;				current_region.setHeight(component.initialConfig.height + current_height)			}						// set title if provided as parameter.			if (typeof title == "string") {				current_region.setTitle(title);				}									// trigger doLayout() and show the pane			current_region.ownerCt.doLayout();			current_region.show();			if(Ext.isMac)				ORYX.Editor.resizeFix();						return current_region;		}				return null;	},	getAvailablePlugins: function(){		var curAvailablePlugins=ORYX.availablePlugins.clone();		curAvailablePlugins.each(function(plugin){			if(this.loadedPlugins.find(function(loadedPlugin){				return loadedPlugin.type==this.name;			}.bind(plugin))){				plugin.engaged=true;			}else{				plugin.engaged=false;			}			}.bind(this));		return curAvailablePlugins;	},	loadScript: function (url, callback){	    var script = document.createElement("script")	    script.type = "text/javascript";	    if (script.readyState){  //IE	        script.onreadystatechange = function(){	            if (script.readyState == "loaded" || script.readyState == "complete"){	                script.onreadystatechange = null;	                callback();	            }        	};    	} else {  //Others	        script.onload = function(){	            callback();	        };		}	    script.src = url;		document.getElementsByTagName("head")[0].appendChild(script);	},	/**	 * activate Plugin	 * 	 * @param {String} name	 * @param {Function} callback	 * 		callback(sucess, [errorCode])	 * 			errorCodes: NOTUSEINSTENCILSET, REQUIRESTENCILSET, NOTFOUND, YETACTIVATED	 */	activatePluginByName: function(name, callback, loadTry){		var match=this.getAvailablePlugins().find(function(value){return value.name==name});		if(match && (!match.engaged || (match.engaged==='false'))){						var loadedStencilSetsNamespaces = this.getStencilSets().keys();				var facade = this._getPluginFacade();				var newPlugin;				var me=this;				ORYX.Log.debug("Initializing plugin '%0'", match.name);									if (!match.requires 	|| !match.requires.namespaces 	|| match.requires.namespaces.any(function(req){ return loadedStencilSetsNamespaces.indexOf(req) >= 0 }) ){						if(!match.notUsesIn 	|| !match.notUsesIn.namespaces 	|| !match.notUsesIn.namespaces.any(function(req){ return loadedStencilSetsNamespaces.indexOf(req) >= 0 })){						try {												var className 	= eval(match.name);							var newPlugin = new className(facade, match);							newPlugin.type = match.name;														// If there is an GUI-Plugin, they get all Plugins-Offer-Meta-Data							if (newPlugin.registryChanged) 								newPlugin.registryChanged(me.pluginsData);														// If there have an onSelection-Method it will pushed to the Editor Event-Handler							if (newPlugin.onSelectionChanged) 								me.registerOnEvent(ORYX.CONFIG.EVENT_SELECTION_CHANGED, newPlugin.onSelectionChanged.bind(newPlugin));							this.loadedPlugins.push(newPlugin);							this.loadedPlugins.each(function(loaded){								if(loaded.registryChanged)									loaded.registryChanged(this.pluginsData);							}.bind(me));							callback(true);											} catch(e) {						ORYX.Log.warn("Plugin %0 is not available", match.name);						if(!!loadTry){							callback(false,"INITFAILED");							return;						}						this.loadScript("plugins/scripts/"+match.source, this.activatePluginByName.bind(this,match.name,callback,true));					}					}else{						callback(false,"NOTUSEINSTENCILSET");						ORYX.Log.info("Plugin need a stencilset which is not loaded'", match.name);					}												} else {					callback(false,"REQUIRESTENCILSET");					ORYX.Log.info("Plugin need a stencilset which is not loaded'", match.name);				}						}else{				callback(false, match?"NOTFOUND":"YETACTIVATED");				//TODO error handling			}	},	/**	 *  Laden der Plugins	 */	loadPlugins: function() {				// if there should be plugins but still are none, try again.		// TODO this should wait for every plugin respectively.		/*if (!ORYX.Plugins && ORYX.availablePlugins.length > 0) {			window.setTimeout(this.loadPlugins.bind(this), 100);			return;		}*/				var me = this;		var newPlugins = [];		var loadedStencilSetsNamespaces = this.getStencilSets().keys();		// Available Plugins will be initalize		var facade = this._getPluginFacade();				// If there is an Array where all plugins are described, than only take those		// (that comes from the usage of oryx with a mashup api)		if( ORYX.MashupAPI && ORYX.MashupAPI.loadablePlugins && ORYX.MashupAPI.loadablePlugins instanceof Array ){					// Get the plugins from the available plugins (those who are in the plugins.xml)			ORYX.availablePlugins = $A(ORYX.availablePlugins).findAll(function(value){										return ORYX.MashupAPI.loadablePlugins.include( value.name )									})						// Add those plugins to the list, which are only in the loadablePlugins list			ORYX.MashupAPI.loadablePlugins.each(function( className ){				if( !(ORYX.availablePlugins.find(function(val){ return val.name == className }))){					ORYX.availablePlugins.push( {name: className } );				}			})		}						ORYX.availablePlugins.each(function(value) {			ORYX.Log.debug("Initializing plugin '%0'", value.name);				if( (!value.requires 	|| !value.requires.namespaces 	|| value.requires.namespaces.any(function(req){ return loadedStencilSetsNamespaces.indexOf(req) >= 0 }) ) &&					(!value.notUsesIn 	|| !value.notUsesIn.namespaces 	|| !value.notUsesIn.namespaces.any(function(req){ return loadedStencilSetsNamespaces.indexOf(req) >= 0 }) )&&					/*only load activated plugins or undefined */					(value.engaged || (value.engaged===undefined)) ){				try {					var className 	= eval(value.name);					if( className ){						var plugin		= new className(facade, value);						plugin.type		= value.name;						newPlugins.push( plugin );						plugin.engaged=true;					}				} catch(e) {					ORYX.Log.warn("Plugin %0 is not available", value.name);				}										} else {				ORYX.Log.info("Plugin need a stencilset which is not loaded'", value.name);			}					});		newPlugins.each(function(value) {			// If there is an GUI-Plugin, they get all Plugins-Offer-Meta-Data			if(value.registryChanged)				value.registryChanged(me.pluginsData);			// If there have an onSelection-Method it will pushed to the Editor Event-Handler			if(value.onSelectionChanged)				me.registerOnEvent(ORYX.CONFIG.EVENT_SELECTION_CHANGED, value.onSelectionChanged.bind(value));		});		this.loadedPlugins = newPlugins;				// Hack for the Scrollbars		if(Ext.isMac) {			ORYX.Editor.resizeFix();		}				this.registerPluginsOnKeyEvents();				this.setSelection();			},    /**     * Loads the stencil set extension file, defined in ORYX.CONFIG.SS_EXTENSIONS_CONFIG     */    _loadStencilSetExtensionConfig: function(){        // load ss extensions        new Ajax.Request(ORYX.CONFIG.SS_EXTENSIONS_CONFIG, {            method: 'GET',            asynchronous: false,            onSuccess: (function(transport) {                var jsonObject = Ext.decode(transport.responseText);                this.ss_extensions_def = jsonObject;            }).bind(this),            onFailure: (function(transport) {                ORYX.Log.error("Editor._loadStencilSetExtensionConfig: Loading stencil set extension configuration file failed." + transport);            }).bind(this)        });    },	/**	 * Creates the Canvas	 * @param {String} [stencilType] The stencil type used for creating the canvas. If not given, a stencil with myBeRoot = true from current stencil set is taken.	 * @param {Object} [canvasConfig] Any canvas properties (like language).	 */	_createCanvas: function(stencilType, canvasConfig) {        if (stencilType) {            // Add namespace to stencilType            if (stencilType.search(/^http/) === -1) {                stencilType = this.getStencilSets().values()[0].namespace() + stencilType;            }        }        else {            // Get any root stencil type            stencilType = this.getStencilSets().values()[0].findRootStencilName();        }        		// get the stencil associated with the type		var canvasStencil = ORYX.Core.StencilSet.stencil(stencilType);					if (!canvasStencil) 			ORYX.Log.fatal("Initialisation failed, because the stencil with the type %0 is not part of one of the loaded stencil sets.", stencilType);				// create all dom		// TODO fix border, so the visible canvas has a double border and some spacing to the scrollbars		var div = ORYX.Editor.graft("http://www.w3.org/1999/xhtml", null, ['div']);		// set class for custom styling		div.addClassName("ORYX_Editor");								// create the canvas		this._canvas = new ORYX.Core.Canvas({			width					: ORYX.CONFIG.CANVAS_WIDTH,			height					: ORYX.CONFIG.CANVAS_HEIGHT,			'eventHandlerCallback'	: this.handleEvents.bind(this),			id						: this.id,			parentNode				: div		}, canvasStencil);                if (canvasConfig) {          // Migrate canvasConfig to an RDF-like structure          //FIXME this isn't nice at all because we don't want rdf any longer          var properties = [];          for(field in canvasConfig){            properties.push({              prefix: 'oryx',              name: field,              value: canvasConfig[field]            });          }                      this._canvas.deserialize(properties);        }					},	/**	 * Returns a per-editor singleton plugin facade.	 * To be used in plugin initialization.	 */	_getPluginFacade: function() {		// if there is no pluginfacade already created:		if(!(this._pluginFacade))			// create it.			this._pluginFacade = {				activatePluginByName:		this.activatePluginByName.bind(this),				//deactivatePluginByName:		this.deactivatePluginByName.bind(this),				getAvailablePlugins:	this.getAvailablePlugins.bind(this),				offer:					this.offer.bind(this),				getStencilSets:			this.getStencilSets.bind(this),				getStencilSetExtensionDefinition:function(){ return Object.clone(this.ss_extensions_def||{})}.bind(this),				getRules:				this.getRules.bind(this),				loadStencilSet:			this.loadStencilSet.bind(this),				createShape:			this.createShape.bind(this),				deleteShape:			this.deleteShape.bind(this),				getSelection:			this.getSelection.bind(this),				setSelection:			this.setSelection.bind(this),				updateSelection:		this.updateSelection.bind(this),				getCanvas:				this.getCanvas.bind(this),								importJSON:				this.importJSON.bind(this),				importERDF:				this.importERDF.bind(this),				getERDF:				this.getERDF.bind(this),                getJSON:                this.getJSON.bind(this),                getSerializedJSON:      this.getSerializedJSON.bind(this),								executeCommands:		this.executeCommands.bind(this),				isExecutingCommands:	this.isExecutingCommands.bind(this),								registerOnEvent:		this.registerOnEvent.bind(this),				unregisterOnEvent:		this.unregisterOnEvent.bind(this),				raiseEvent:				this.handleEvents.bind(this),				enableEvent:			this.enableEvent.bind(this),				disableEvent:			this.disableEvent.bind(this),								eventCoordinates:		this.eventCoordinates.bind(this),				addToRegion:			this.addToRegion.bind(this),								getModelMetaData:		this.getModelMetaData.bind(this)			};		// return it.		return this._pluginFacade;	},	isExecutingCommands: function(){		return !!this.commandExecuting;	},	/**	 * Implementes the command pattern	 * (The real usage of the command pattern	 * is implemented and shown in the Plugins/undo.js)	 *	 * @param <Oryx.Core.Command>[] Array of commands	 */	executeCommands: function(commands){				if (!this.commandStack){			this.commandStack = [];		}		if (!this.commandStackExecuted){			this.commandStackExecuted = [];		}						this.commandStack = [].concat(this.commandStack)							  .concat(commands);				// Check if already executes		if (this.commandExecuting){ return; }				// Start execution		this.commandExecuting = true;				// Iterate over all commands		while(this.commandStack.length > 0){			var command = this.commandStack.shift();			// and execute it			command.execute();			this.commandStackExecuted.push(command);		}				// Raise event for executing commands		this.handleEvents({			type		: ORYX.CONFIG.EVENT_EXECUTE_COMMANDS,			commands	: this.commandStackExecuted		});				// Remove temporary vars		delete this.commandStack;		delete this.commandStackExecuted;		delete this.commandExecuting;						this.updateSelection();	},	    /**     * Returns JSON of underlying canvas (calls ORYX.Canvas#toJSON()).     * @return {Object} Returns JSON representation as JSON object.     */    getJSON: function(){        var canvas = this.getCanvas().toJSON();        canvas.ssextensions = this.getStencilSets().values()[0].extensions().keys().findAll(function(sse){ return !sse.endsWith('/meta#') });        return canvas;    },        /**     * Serializes a call to toJSON().     * @return {String} Returns JSON representation as string.     */    getSerializedJSON: function(){        return Ext.encode(this.getJSON());    },	    /**	 * @return {String} Returns eRDF representation.	 * @deprecated Use ORYX.Editor#getJSON instead, if possible.	 */	getERDF:function(){		// Get the serialized dom        var serializedDOM = DataManager.serializeDOM( this._getPluginFacade() );				// Add xml definition if there is no		serializedDOM = '<?xml version="1.0" encoding="utf-8"?>' +						'<html xmlns="http://www.w3.org/1999/xhtml" ' +						'xmlns:b3mn="http://b3mn.org/2007/b3mn" ' +						'xmlns:ext="http://b3mn.org/2007/ext" ' +						'xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" ' +						'xmlns:atom="http://b3mn.org/2007/atom+xhtml">' +						'<head profile="http://purl.org/NET/erdf/profile">' +						'<link rel="schema.dc" href="http://purl.org/dc/elements/1.1/" />' +						'<link rel="schema.dcTerms" href="http://purl.org/dc/terms/ " />' +						'<link rel="schema.b3mn" href="http://b3mn.org" />' +						'<link rel="schema.oryx" href="http://oryx-editor.org/" />' +						'<link rel="schema.raziel" href="http://raziel.org/" />' +						'<base href="' +						location.href.split("?")[0] +						'" />' +						'</head><body>' +						serializedDOM +						'</body></html>';				return serializedDOM;					},    	/**	* Imports shapes in JSON as expected by {@link ORYX.Editor#loadSerialized}	* @param {Object|String} jsonObject The (serialized) json object to be imported	* @param {boolean } [noSelectionAfterImport=false] Set to true if no shapes should be selected after import	* @throws {SyntaxError} If the serialized json object contains syntax errors	*/	importJSON: function(jsonObject, noSelectionAfterImport) {		        try {            jsonObject = this.renewResourceIds(jsonObject);        } catch(error){            throw error;        }     		//check, if the imported json model can be loaded in this editor		// (stencil set has to fit)		if(jsonObject.stencilset.namespace && jsonObject.stencilset.namespace !== this.getCanvas().getStencil().stencilSet().namespace()) {			Ext.Msg.alert(ORYX.I18N.JSONImport.title, String.format(ORYX.I18N.JSONImport.wrongSS, jsonObject.stencilset.namespace, this.getCanvas().getStencil().stencilSet().namespace()));			return null;		} else {			var commandClass = ORYX.Core.Command.extend({			construct: function(jsonObject, loadSerializedCB, noSelectionAfterImport, facade){				this.jsonObject = jsonObject;				this.noSelection = noSelectionAfterImport;				this.facade = facade;				this.shapes;				this.connections = [];				this.parents = new Hash();				this.selection = this.facade.getSelection();				this.loadSerialized = loadSerializedCB;			},						execute: function(){								if (!this.shapes) {					// Import the shapes out of the serialization							this.shapes	= this.loadSerialized( this.jsonObject );												//store all connections					this.shapes.each(function(shape) {												if (shape.getDockers) {							var dockers = shape.getDockers();							if (dockers) {								if (dockers.length > 0) {									this.connections.push([dockers.first(), dockers.first().getDockedShape(), dockers.first().referencePoint]);								}								if (dockers.length > 1) {									this.connections.push([dockers.last(), dockers.last().getDockedShape(), dockers.last().referencePoint]);								}							}						}												//store parents						this.parents[shape.id] = shape.parent;					}.bind(this));				} else {					this.shapes.each(function(shape) {						this.parents[shape.id].add(shape);					}.bind(this));										this.connections.each(function(con) {						con[0].setDockedShape(con[1]);						con[0].setReferencePoint(con[2]);						con[0].update();					});				}								//this.parents.values().uniq().invoke("update");				this.facade.getCanvas().update();												if(!this.noSelection)					this.facade.setSelection(this.shapes);				else					this.facade.updateSelection();									// call updateSize again, because during loadSerialized the edges' bounds  				// are not yet initialized properly				this.facade.getCanvas().updateSize();										},				rollback: function(){					var selection = this.facade.getSelection();										this.shapes.each(function(shape) {						selection = selection.without(shape);						this.facade.deleteShape(shape);					}.bind(this));										/*this.parents.values().uniq().each(function(parent) {						if(!this.shapes.member(parent))							parent.update();					}.bind(this));*/										this.facade.getCanvas().update();										this.facade.setSelection(selection);				}			})						var command = new commandClass(jsonObject, 											this.loadSerialized.bind(this),											noSelectionAfterImport,											this._getPluginFacade());						this.executeCommands([command]);							return command.shapes.clone();		}	},        /**     * This method renew all resource Ids and according references.     * Warning: The implementation performs a substitution on the serialized object for     * easier implementation. This results in a low performance which is acceptable if this     * is only used when importing models.     * @param {Object|String} jsonObject     * @throws {SyntaxError} If the serialized json object contains syntax errors.     * @return {Object} The jsonObject with renewed ids.     * @private     */    renewResourceIds: function(jsonObject){        // For renewing resource ids, a serialized and object version is needed        if(Ext.type(jsonObject) === "string"){            try {                var serJsonObject = jsonObject;                jsonObject = Ext.decode(jsonObject);            } catch(error){                throw new SyntaxError(error.message);            }        } else {            var serJsonObject = Ext.encode(jsonObject);        }                        // collect all resourceIds recursively        var collectResourceIds = function(shapes){            if(!shapes) return [];                        return shapes.map(function(shape){                return collectResourceIds(shape.childShapes).concat(shape.resourceId);            }).flatten();        }        var resourceIds = collectResourceIds(jsonObject.childShapes);                // Replace each resource id by a new one        resourceIds.each(function(oldResourceId){            var newResourceId = ORYX.Editor.provideId();            serJsonObject = serJsonObject.gsub('"'+oldResourceId+'"', '"'+newResourceId+'"')        });                return Ext.decode(serJsonObject);    },		/**	 * Import erdf structure to the editor	 *	 */	importERDF: function( erdfDOM ){		var serialized = this.parseToSerializeObjects( erdfDOM );					if(serialized)			return this.importJSON(serialized, true);	},	/**	 * Parses one model (eRDF) to the serialized form (JSON)	 * 	 * @param {Object} oneProcessData	 * @return {Object} The JSON form of given eRDF model, or null if it couldn't be extracted 	 */	parseToSerializeObjects: function( oneProcessData ){				// Firefox splits a long text node into chunks of 4096 characters.		// To prevent truncation of long property values the normalize method must be called		if(oneProcessData.normalize) oneProcessData.normalize();		try {			var xsl = "";			var source=ORYX.PATH + "lib/extract-rdf.xsl";			new Ajax.Request(source, {				asynchronous: false,				method: 'get',				onSuccess: function(transport){					xsl = transport.responseText				}.bind(this),				onFailure: (function(transport){					ORYX.Log.error("XSL load failed" + transport);				}).bind(this)			});			var domParser = new DOMParser();			var xmlObject = oneProcessData;			var xslObject = domParser.parseFromString(xsl, "text/xml");        	var xsltProcessor = new XSLTProcessor();        	var xslRef = document.implementation.createDocument("", "", null);        	xsltProcessor.importStylesheet(xslObject);                    var new_rdf = xsltProcessor.transformToFragment(xmlObject, document);            var serialized_rdf = (new XMLSerializer()).serializeToString(new_rdf);			}catch(e){			Ext.Msg.alert("Oryx", error);			var serialized_rdf = "";		}                        // Firefox 2 to 3 problem?!            serialized_rdf = !serialized_rdf.startsWith("<?xml") ? "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + serialized_rdf : serialized_rdf;        var req = new Ajax.Request(ORYX.CONFIG.ROOT_PATH+"rdf2json", {          method: 'POST',          asynchronous: false,          onSuccess: function(transport) {              Ext.decode(transport.responseText);          },          parameters: {              rdf: serialized_rdf          }        });                return Ext.decode(req.transport.responseText);	},    /**     * Loads serialized model to the oryx.     * @example     * editor.loadSerialized({     *    resourceId: "mymodel1",     *    childShapes: [     *       {     *          stencil:{ id:"Subprocess" },     *          outgoing:[{resourceId: 'aShape'}],     *          target: {resourceId: 'aShape'},     *          bounds:{ lowerRight:{ y:510, x:633 }, upperLeft:{ y:146, x:210 } },     *          resourceId: "myshape1",     *          childShapes:[],     *          properties:{},     *       }     *    ],     *    properties:{     *       language: "English"     *    },     *    stencilset:{     *       url:"http://localhost:8080/oryx/stencilsets/bpmn1.1/bpmn1.1.json"     *    },     *    stencil:{     *       id:"BPMNDiagram"     *    }     * });     * @param {Object} model Description of the model to load.     * @param {Array} [model.ssextensions] List of stenctil set extensions.     * @param {String} model.stencilset.url     * @param {String} model.stencil.id      * @param {Array} model.childShapes     * @param {Array} [model.properties]     * @param {String} model.resourceId     * @return {ORYX.Core.Shape[]} List of created shapes     * @methodOf ORYX.Editor.prototype     */    loadSerialized: function(model, requestMeta){        var canvas  = this.getCanvas();              // Bugfix (cf. http://code.google.com/p/oryx-editor/issues/detail?id=240)        // Deserialize the canvas' stencil set extensions properties first!        this.loadSSExtensions(model.ssextensions);				// Load Meta Data Extension if available		// #Signavio		if (requestMeta === true) {			var metaDataExtension = this.getExtensionForMetaData();			if (metaDataExtension) {				this.loadSSExtension(metaDataExtension);			}		}		        var shapes = this.getCanvas().addShapeObjects(model.childShapes, this.handleEvents.bind(this));                if(model.properties) {        	for(key in model.properties) {        		var value = model.properties[key];				var prop = this.getCanvas().getStencil().property("oryx-"+key);        		if (!(typeof value === "string") && (!prop || !prop.isList())) {        			value = Ext.encode(value);        		}            	this.getCanvas().setProperty("oryx-" + key, value);            }        }                        this.getCanvas().updateSize();				// Force to update the selection		this.selection = [null];		this.setSelection([]);		        return shapes;    },        /**     * Modification of loadSerialized ... call captureOnlyServiceNeighbors before add shape to the canvas      * used for initiating a query process     * added by Nattawat Nonsung     * add new parameter queryJSON which is the details of this query     */    loadSerializedForQuery: function(model, requestMeta, queryJson){        var canvas  = this.getCanvas();              // Bugfix (cf. http://code.google.com/p/oryx-editor/issues/detail?id=240)        // Deserialize the canvas' stencil set extensions properties first!        this.loadSSExtensions(model.ssextensions);				// Load Meta Data Extension if available		// #Signavio		if (requestMeta === true) {			var metaDataExtension = this.getExtensionForMetaData();			if (metaDataExtension) {				this.loadSSExtension(metaDataExtension);			}		}				//capture service neighbors in model.childShapes		this.captureOnlyServiceNeighbors(model, queryJson);		        var shapes = this.getCanvas().addShapeObjects(model.childShapes, this.handleEvents.bind(this));                if(model.properties) {        	for(key in model.properties) {        		var value = model.properties[key];				var prop = this.getCanvas().getStencil().property("oryx-"+key);        		if (!(typeof value === "string") && (!prop || !prop.isList())) {        			value = Ext.encode(value);        		}            	this.getCanvas().setProperty("oryx-" + key, value);            }        }                        this.getCanvas().updateSize();				// Force to update the selection		this.selection = [null];		this.setSelection([]);		        return shapes;    },        findChild: function(model, resourceId){    	for(var i=0; i<model.childShapes.length; i++){    		if(model.childShapes[i].resourceId == resourceId){    			return model.childShapes[i];    		}    	}    },        findTargetOfOutgoingSequence: function(model, sequenceId){    	for(var i=0; i<model.childShapes.length; i++){    		if(model.childShapes[i].stencil.id == 'SequenceFlow' && model.childShapes[i].resourceId == sequenceId){    			//found sequence, return its target    			return model.childShapes[i].target.resourceId;    		}    	}    },        //return sequence objects    findPreviousSequence: function(model, eleId){    	var sequence = [];    	for(var i=0; i<model.childShapes.length; i++){    		if(model.childShapes[i].stencil.id == 'SequenceFlow' && model.childShapes[i].target.resourceId == eleId){    			sequence.push(model.childShapes[i]);    		}    	}    	return sequence;    },        //return connector object    findConnectorOfSequence: function(model, sequenceId){    	for(var i=0; i<model.childShapes.length; i++){    		for(var j=0; j<model.childShapes[i].outgoing.length; j++){    			if(model.childShapes[i].outgoing[j].resourceId == sequenceId){    				return model.childShapes[i];    			}    		}    	}    },        isContain: function(array, txt){    	var contain = false;    	for(var i=0; i<array.length; i++){    		if(array[i] == txt){    			contain = true;    		}    	}    	return contain;    },        /** find next element of a element specified as a parameter     * */    findNextElement: function(model, taskId, neighbors, includedIds, alreadyVisited){		includedIds.push(taskId);		var targetTask = this.findChild(model, taskId);				//find outgoing sequence		for(var j=0; j<targetTask.outgoing.length; j++ ){			includedIds.push(targetTask.outgoing[j].resourceId);			var targetId = this.findTargetOfOutgoingSequence(model, targetTask.outgoing[j].resourceId);			var targetElement = this.findChild(model, targetId);			if(targetElement.stencil.id == 'Task' || 				targetElement.stencil.id == 'CollapsedSubprocess' || 				targetElement.stencil.id == 'StartNoneEvent' ||				targetElement.stencil.id == 'EndNoneEvent' ){				//found neighbor				includedIds.push(targetElement.resourceId);				if(!this.isContain(alreadyVisited, targetElement.resourceId)){					alreadyVisited.push(targetElement.resourceId);					neighbors.push(targetElement);				}			}else{				if(!this.isContain(includedIds, targetElement.resourceId)){					this.findNextElement(model, targetElement.resourceId, neighbors, includedIds, alreadyVisited);					this.findPreviousElement(model, targetElement.resourceId, neighbors, includedIds, alreadyVisited);				}			}		}    	    },        /** find previous element of a element specified as a parameter     * */    findPreviousElement: function(model, taskId, neighbors, includedIds, alreadyVisited){		includedIds.push(taskId);		var targetTask = this.findChild(model, taskId);		var sequences = this.findPreviousSequence(model, taskId);		for(var i=0; i<sequences.length; i++){			includedIds.push(sequences[i].resourceId);			var connector = this.findConnectorOfSequence(model, sequences[i].resourceId);			if(connector.stencil.id == 'Task' || 				connector.stencil.id == 'CollapsedSubprocess' || 				connector.stencil.id == 'StartNoneEvent' ||				connector.stencil.id == 'EndNoneEvent' ){				//found neighbor				includedIds.push(connector.resourceId);				if(!this.isContain(alreadyVisited, connector.resourceId)){					alreadyVisited.push(connector.resourceId);					neighbors.push(connector);				}			}else{				if(!this.isContain(includedIds, connector.resourceId)){					this.findPreviousElement(model, connector.resourceId, neighbors, includedIds, alreadyVisited);					this.findNextElement(model, connector.resourceId, neighbors, includedIds, alreadyVisited);				}			}		}    },            addIncludedIds: function(newIds, includedIds){    	for(var i=0; i<newIds.length; i++){    		var exist = false;    		for(var j=0; j<includedIds.length; j++){    			if(includedIds[j] == newIds[i]){    				exist = true;    			}    		}    		if(!exist){    			includedIds.push(newIds[i]);    		}    	}    },        /**     * used for extract only neighbors within a specific zone     * it will change model.childShapes    */    captureOnlyServiceNeighbors: function(model, queryJson){    	    	var noOfChilds = model.childShapes.length;		var includedIds = [];		var neighbors = []; //used to run for each zone -- it is array of object		var alreadyVisited = [];     	//find taget task for first zone		for(var i=0; i<noOfChilds; i++){			if(model.childShapes[i].stencil.id == 'Task' || model.childShapes[i].stencil.id == 'CollapsedSubprocess'){				if(model.childShapes[i].properties.name.strip() == queryJson.targetTask.strip()){					//target task					var targetId = model.childShapes[i].resourceId;					alreadyVisited.push(targetId);					var preIds = [];					this.findPreviousElement(model, targetId, neighbors, preIds, alreadyVisited);					var postIds = [];					this.findNextElement(model, targetId, neighbors, postIds, alreadyVisited);										//add discover ids into includedIds					this.addIncludedIds(preIds, includedIds);					this.addIncludedIds(postIds, includedIds);										break;				}			}		}				//for the other zones use neighbors but exclude start and end		for(var i=2; i<=queryJson.zone; i++){			var neighborsTemp = [];			for(var j=0; j<neighbors.length; j++){				neighborsTemp.push(neighbors[j]);			}			neighbors = [];			for(var j=0; j<neighborsTemp.length; j++){				if(neighborsTemp[j].stencil.id != 'StartNoneEvent' &&						neighborsTemp[j].stencil.id != 'StopNoneEvent'){					var preIds = [];					this.findPreviousElement(model, neighborsTemp[j].resourceId, neighbors, preIds, alreadyVisited);					var postIds = [];					this.findNextElement(model, neighborsTemp[j].resourceId, neighbors, postIds, alreadyVisited);										//add discover ids into includedIds					this.addIncludedIds(preIds, includedIds);					this.addIncludedIds(postIds, includedIds);				}			}		}		   		var excludedIds = [];   		for(var i=0; i<model.childShapes.length; i++){   			var include = false;   			for(var j=0; j<includedIds.length; j++){   				if(model.childShapes[i].resourceId == includedIds[j]){   					include = true;   					break;   				}   			}   			if(!include){   				excludedIds.push(model.childShapes[i].resourceId);   			}   		}   		   		//remove unselected components   		for(var i=0; i<excludedIds.length; i++){   			for(var j=0; j<model.childShapes.length; j++){   				if(model.childShapes[j].resourceId == excludedIds[i]){   					model.childShapes.splice(j,1);   					break;   				}   			}   		}	       },		/**	 * Return the namespace of the extension which	 * provided all the self defined meta data	 * @return {String} Returns null if no extension is defined, otherwise the namespace	 *	 */	getExtensionForMetaData: function(){		if (!this.ss_extensions_def||!(this.ss_extensions_def.extensions instanceof Array)){			return null;		}				var stencilsets = this.getStencilSets();		var extension = this.ss_extensions_def.extensions.find(function(ex){				return !!stencilsets[ex["extends"]] && ex.namespace.endsWith("/meta#");			});					return extension ? extension.namespace || null : null;			},        /**     * Calls ORYX.Editor.prototype.ss_extension_namespace for each element     * @param {Array} ss_extension_namespaces An array of stencil set extension namespaces.     */    loadSSExtensions: function(ss_extension_namespaces){        if(!ss_extension_namespaces) return;        ss_extension_namespaces.each(function(ss_extension_namespace){            this.loadSSExtension(ss_extension_namespace);        }.bind(this));    },		/**	* Loads a stencil set extension.	* The stencil set extensions definiton file must already	* be loaded when the editor is initialized.	*/	loadSSExtension: function(ss_extension_namespace) {								if (this.ss_extensions_def) {			var extension = this.ss_extensions_def.extensions.find(function(ex){				return (ex.namespace == ss_extension_namespace);			});						if (!extension) {				return;			}						var stencilset = this.getStencilSets()[extension["extends"]];						if (!stencilset) {				return;			}						// Check if absolute or relative url			if ((extension["definition"]||"").startsWith("/")){				stencilset.addExtension(extension["definition"])			} else {				stencilset.addExtension(ORYX.CONFIG.SS_EXTENSIONS_FOLDER + extension["definition"])			}						//stencilset.addExtension("/oryx/build/stencilsets/extensions/" + extension["definition"])			this.getRules().initializeRules(stencilset);						this._getPluginFacade().raiseEvent({				type: ORYX.CONFIG.EVENT_STENCIL_SET_LOADED			});		}			},	disableEvent: function(eventType){		if(eventType == ORYX.CONFIG.EVENT_KEYDOWN) {			this._keydownEnabled = false;		}		if(eventType == ORYX.CONFIG.EVENT_KEYUP) {			this._keyupEnabled = false;		}		if(this.DOMEventListeners.keys().member(eventType)) {			var value = this.DOMEventListeners.remove(eventType);			this.DOMEventListeners['disable_' + eventType] = value;		}	},	enableEvent: function(eventType){		if(eventType == ORYX.CONFIG.EVENT_KEYDOWN) {			this._keydownEnabled = true;		}				if(eventType == ORYX.CONFIG.EVENT_KEYUP) {			this._keyupEnabled = true;		}				if(this.DOMEventListeners.keys().member("disable_" + eventType)) {			var value = this.DOMEventListeners.remove("disable_" + eventType);			this.DOMEventListeners[eventType] = value;		}	},	/**	 *  Methods for the PluginFacade	 */	registerOnEvent: function(eventType, callback) {		if(!(this.DOMEventListeners.keys().member(eventType))) {			this.DOMEventListeners[eventType] = [];		}		this.DOMEventListeners[eventType].push(callback);	},	unregisterOnEvent: function(eventType, callback) {		if(this.DOMEventListeners.keys().member(eventType)) {			this.DOMEventListeners[eventType] = this.DOMEventListeners[eventType].without(callback);		} else {			// Event is not supported			// TODO: Error Handling		}	},	getSelection: function() {		return this.selection || [];	},	getStencilSets: function() { 		return ORYX.Core.StencilSet.stencilSets(this.id); 	},		getRules: function() {		return ORYX.Core.StencilSet.rules(this.id);	},		loadStencilSet: function(source) {		try {			ORYX.Core.StencilSet.loadStencilSet(source, this.id);			this.handleEvents({type:ORYX.CONFIG.EVENT_STENCIL_SET_LOADED});		} catch (e) {			ORYX.Log.warn("Requesting stencil set file failed. (" + e + ")");		}	},	offer: function(pluginData) {		if(!this.pluginsData.member(pluginData)){			this.pluginsData.push(pluginData);		}	},		/**	 * It creates an new event or adds the callback, if already existing,	 * for the key combination that the plugin passes in keyCodes attribute	 * of the offer method.	 * 	 * The new key down event fits the schema:	 * 		key.event[.metactrl][.alt][.shift].'thekeyCode'	 */	registerPluginsOnKeyEvents: function() {		this.pluginsData.each(function(pluginData) {						if(pluginData.keyCodes) {								pluginData.keyCodes.each(function(keyComb) {					var eventName = "key.event";										/* Include key action */					eventName += '.' + keyComb.keyAction;										if(keyComb.metaKeys) {						/* Register on ctrl or apple meta key as meta key */						if(keyComb.metaKeys.							indexOf(ORYX.CONFIG.META_KEY_META_CTRL) > -1) {								eventName += "." + ORYX.CONFIG.META_KEY_META_CTRL;						}													/* Register on alt key as meta key */						if(keyComb.metaKeys.							indexOf(ORYX.CONFIG.META_KEY_ALT) > -1) {								eventName += '.' + ORYX.CONFIG.META_KEY_ALT;						}												/* Register on shift key as meta key */						if(keyComb.metaKeys.							indexOf(ORYX.CONFIG.META_KEY_SHIFT) > -1) {								eventName += '.' + ORYX.CONFIG.META_KEY_SHIFT;						}							}										/* Register on the actual key */					if(keyComb.keyCode)	{						eventName += '.' + keyComb.keyCode;					}										/* Register the event */					ORYX.Log.debug("Register Plugin on Key Event: %0", eventName);					if (pluginData.toggle === true && pluginData.buttonInstance) {						this.registerOnEvent(eventName, function(){							pluginData.buttonInstance.toggle(!pluginData.buttonInstance.pressed); // Toggle 							pluginData.functionality.call(pluginData, pluginData.buttonInstance, pluginData.buttonInstance.pressed); // Call function						});					} else {						this.registerOnEvent(eventName, pluginData.functionality)					}								}.bind(this));			}		}.bind(this));	},		isEqual: function(a,b){		return a === b || (a.length === b.length && a.all(function(r){ return b.include(r) }))	},		isDirty: function(a){		return a.any(function(shape){ return shape.isPropertyChanged() })	},	setSelection: function(elements, subSelectionElement, force) {				if (!elements) { elements = []; }		if (!(elements instanceof Array)) { elements = [elements]; }				elements = elements.findAll(function(n){ return n && n instanceof ORYX.Core.Shape });				if (elements[0] instanceof ORYX.Core.Canvas) {			elements = [];		}				if (!force && this.isEqual(this.selection, elements) && !this.isDirty(elements)){			return;		}				this.selection = elements;		this._subSelection = subSelectionElement;				this.handleEvents({type:ORYX.CONFIG.EVENT_SELECTION_CHANGED, elements:elements, subSelection: subSelectionElement, force: !!force})	},		updateSelection: function() {		this.setSelection(this.selection, this._subSelection, true);		/*var s = this.selection;		this.setSelection();		this.setSelection(s);*/	},	getCanvas: function() {		return this._canvas;	},		/**	*	option = {	*		type: string,	*		position: {x:int, y:int},	*		connectingType:	uiObj-Class	*		connectedShape: uiObj	*		draggin: bool	*		namespace: url	*       parent: ORYX.Core.AbstractShape	*		template: a template shape that the newly created inherits properties from.	*		}	*/	createShape: function(option) {		if(option && option.serialize && option.serialize instanceof Array){					var type = option.serialize.find(function(obj){return (obj.prefix+"-"+obj.name) == "oryx-type"});			var stencil = ORYX.Core.StencilSet.stencil(type.value);					if(stencil.type() == 'node'){				var newShapeObject = new ORYX.Core.Node({'eventHandlerCallback':this.handleEvents.bind(this)}, stencil);				} else {				var newShapeObject = new ORYX.Core.Edge({'eventHandlerCallback':this.handleEvents.bind(this)}, stencil);				}					this.getCanvas().add(newShapeObject);			newShapeObject.deserialize(option.serialize);					return newShapeObject;		}		// If there is no argument, throw an exception		if(!option || !option.type || !option.namespace) { throw "To create a new shape you have to give an argument with type and namespace";}				var canvas = this.getCanvas();		var newShapeObject;		// Get the shape type		var shapetype = option.type;		// Get the stencil set		var sset = ORYX.Core.StencilSet.stencilSet(option.namespace);		// Create an New Shape, dependents on an Edge or a Node		if(sset.stencil(shapetype).type() == "node") {			newShapeObject = new ORYX.Core.Node({'eventHandlerCallback':this.handleEvents.bind(this)}, sset.stencil(shapetype))		} else {			newShapeObject = new ORYX.Core.Edge({'eventHandlerCallback':this.handleEvents.bind(this)}, sset.stencil(shapetype))		}				// when there is a template, inherit the properties.		if(option.template) {			newShapeObject._jsonStencil.properties = option.template._jsonStencil.properties;			newShapeObject.postProcessProperties();		}		// Add to the canvas		if(option.parent && newShapeObject instanceof ORYX.Core.Node) {			option.parent.add(newShapeObject);		} else {			canvas.add(newShapeObject);		}						// Set the position		var point = option.position ? option.position : {x:100, y:200};					var con;		// If there is create a shape and in the argument there is given an ConnectingType and is instance of an edge		if(option.connectingType && option.connectedShape && !(newShapeObject instanceof ORYX.Core.Edge)) {			// there will be create a new Edge			con = new ORYX.Core.Edge({'eventHandlerCallback':this.handleEvents.bind(this)}, sset.stencil(option.connectingType));						// And both endings dockers will be referenced to the both shapes			con.dockers.first().setDockedShape(option.connectedShape);						var magnet = option.connectedShape.getDefaultMagnet()			var cPoint = magnet ? magnet.bounds.center() : option.connectedShape.bounds.midPoint();			con.dockers.first().setReferencePoint( cPoint );			con.dockers.last().setDockedShape(newShapeObject);			con.dockers.last().setReferencePoint(newShapeObject.getDefaultMagnet().bounds.center());								// The Edge will be added to the canvas and be updated			canvas.add(con);				//con.update();					} 				// Move the new Shape to the position		if(newShapeObject instanceof ORYX.Core.Edge && option.connectedShape) {			newShapeObject.dockers.first().setDockedShape(option.connectedShape);						if( option.connectedShape instanceof ORYX.Core.Node ){				newShapeObject.dockers.first().setReferencePoint(option.connectedShape.getDefaultMagnet().bounds.center());									newShapeObject.dockers.last().bounds.centerMoveTo(point);						} else {				newShapeObject.dockers.first().setReferencePoint(option.connectedShape.bounds.midPoint());											}		} else {						var b = newShapeObject.bounds			if( newShapeObject instanceof ORYX.Core.Node && newShapeObject.dockers.length == 1){				b = newShapeObject.dockers.first().bounds			}						b.centerMoveTo(point);						var upL = b.upperLeft();			b.moveBy( -Math.min(upL.x, 0) , -Math.min(upL.y, 0) )						var lwR = b.lowerRight();			b.moveBy( -Math.max(lwR.x-canvas.bounds.width(), 0) , -Math.max(lwR.y-canvas.bounds.height(), 0) )					}				// Update the shape		if (newShapeObject instanceof ORYX.Core.Edge) {			newShapeObject._update(false);		}				// And refresh the selection		if(!(newShapeObject instanceof ORYX.Core.Edge)&&!(option.dontUpdateSelection)) {			this.setSelection([newShapeObject]);		}				if(con && con.alignDockers) {			con.alignDockers();		} 		if(newShapeObject.alignDockers) {			newShapeObject.alignDockers();		}		return newShapeObject;	},		deleteShape: function(shape) {				if (!shape || !shape.parent){ return }				//remove shape from parent		// this also removes it from DOM		shape.parent.remove(shape);				//delete references to outgoing edges		shape.getOutgoingShapes().each(function(os) {			var docker = os.getDockers().first();			if(docker && docker.getDockedShape() == shape) {				docker.setDockedShape(undefined);			}		});				//delete references to incoming edges		shape.getIncomingShapes().each(function(is) {			var docker = is.getDockers().last();			if(docker && docker.getDockedShape() == shape) {				docker.setDockedShape(undefined);			}		});				//delete references of the shape's dockers		shape.getDockers().each(function(docker) {			docker.setDockedShape(undefined);		});	},		/**	 * Returns an object with meta data about the model.	 * Like name, description, ...	 * 	 * Empty object with the current backend.	 * 	 * @return {Object} Meta data about the model	 */	getModelMetaData: function() {		return this.modelMetaData;	},	/* Event-Handler Methods */		/**	* Helper method to execute an event immediately. The event is not	* scheduled in the _eventsQueue. Needed to handle Layout-Callbacks.	*/	_executeEventImmediately: function(eventObj) {		if(this.DOMEventListeners.keys().member(eventObj.event.type)) {			this.DOMEventListeners[eventObj.event.type].each((function(value) {				value(eventObj.event, eventObj.arg);					}).bind(this));		}	},	_executeEvents: function() {		this._queueRunning = true;		while(this._eventsQueue.length > 0) {			var val = this._eventsQueue.shift();			this._executeEventImmediately(val);		}		this._queueRunning = false;	},		/**	 * Leitet die Events an die Editor-Spezifischen Event-Methoden weiter	 * @param {Object} event Event , welches gefeuert wurde	 * @param {Object} uiObj Target-UiObj	 */	handleEvents: function(event, uiObj) {				ORYX.Log.trace("Dispatching event type %0 on %1", event.type, uiObj);		switch(event.type) {			case ORYX.CONFIG.EVENT_MOUSEDOWN:				this._handleMouseDown(event, uiObj);				break;			case ORYX.CONFIG.EVENT_MOUSEMOVE:				this._handleMouseMove(event, uiObj);				break;			case ORYX.CONFIG.EVENT_MOUSEUP:				this._handleMouseUp(event, uiObj);				break;			case ORYX.CONFIG.EVENT_MOUSEOVER:				this._handleMouseHover(event, uiObj);				break;			case ORYX.CONFIG.EVENT_MOUSEOUT:				this._handleMouseOut(event, uiObj);				break;		}		/* Force execution if necessary. Used while handle Layout-Callbacks. */		if(event.forceExecution) {			this._executeEventImmediately({event: event, arg: uiObj});		} else {			this._eventsQueue.push({event: event, arg: uiObj});		}				if(!this._queueRunning) {			this._executeEvents();		}				// TODO: Make this return whether no listener returned false.		// So that, when one considers bubbling undesireable, it won't happen.		return false;	},	isValidEvent: function(e){		try {			var isInput = ["INPUT", "TEXTAREA"].include(e.target.tagName.toUpperCase());			var gridHasFocus = e.target.className.include("x-grid3-focus") && !e.target.className.include("x-grid3-focus-canvas");			return !isInput && !gridHasFocus;		} catch(e){			return false;		}	},	catchKeyUpEvents: function(event) {		if(!this._keyupEnabled) {			return;		}		/* assure we have the current event. */        if (!event)             event = window.event;        		// Checks if the event comes from some input field		if (!this.isValidEvent(event)){			return;		}				/* Create key up event type */		var keyUpEvent = this.createKeyCombEvent(event,	ORYX.CONFIG.KEY_ACTION_UP);				ORYX.Log.debug("Key Event to handle: %0", keyUpEvent);		/* forward to dispatching. */		this.handleEvents({type: keyUpEvent, event:event});	},		/**	 * Catches all key down events and forward the appropriated event to 	 * dispatching concerning to the pressed keys.	 * 	 * @param {Event} 	 * 		The key down event to handle	 */	catchKeyDownEvents: function(event) {		if(!this._keydownEnabled) {			return;		}		/* Assure we have the current event. */        if (!event)             event = window.event;        		/* Fixed in FF3 */		// This is a mac-specific fix. The mozilla event object has no knowledge		// of meta key modifier on osx, however, it is needed for certain		// shortcuts. This fix adds the metaKey field to the event object, so		// that all listeners that registered per Oryx plugin facade profit from		// this. The original bug is filed in		// https://bugzilla.mozilla.org/show_bug.cgi?id=418334		//if (this.__currentKey == ORYX.CONFIG.KEY_CODE_META) {		//	event.appleMetaKey = true;		//}		//this.__currentKey = pressedKey;				// Checks if the event comes from some input field		if (!this.isValidEvent(event)){			return;		}				/* Create key up event type */		var keyDownEvent = this.createKeyCombEvent(event, ORYX.CONFIG.KEY_ACTION_DOWN);				ORYX.Log.debug("Key Event to handle: %0", keyDownEvent);				/* Forward to dispatching. */		this.handleEvents({type: keyDownEvent,event: event});	},		/**	 * Creates the event type name concerning to the pressed keys.	 * 	 * @param {Event} keyDownEvent	 * 		The source keyDownEvent to build up the event name	 */	createKeyCombEvent: function(keyEvent, keyAction) {		/* Get the currently pressed key code. */        var pressedKey = keyEvent.which || keyEvent.keyCode;		//this.__currentKey = pressedKey;				/* Event name */		var eventName = "key.event";				/* Key action */		if(keyAction) {			eventName += "." + keyAction;		}				/* Ctrl or apple meta key is pressed */		if(keyEvent.ctrlKey || keyEvent.metaKey) {			eventName += "." + ORYX.CONFIG.META_KEY_META_CTRL;		}				/* Alt key is pressed */		if(keyEvent.altKey) {			eventName += "." + ORYX.CONFIG.META_KEY_ALT;		}				/* Alt key is pressed */		if(keyEvent.shiftKey) {			eventName += "." + ORYX.CONFIG.META_KEY_SHIFT;		}				/* Return the composed event name */		return  eventName + "." + pressedKey;	},	_handleMouseDown: function(event, uiObj) {				// get canvas.		var canvas = this.getCanvas();		// Try to get the focus		canvas.focus()			// find the shape that is responsible for this element's id.		var element = event.currentTarget;		var elementController = uiObj;		// gather information on selection.		var currentIsSelectable = (elementController !== null) &&			(elementController !== undefined) && (elementController.isSelectable);		var currentIsMovable = (elementController !== null) &&			(elementController !== undefined) && (elementController.isMovable);		var modifierKeyPressed = event.shiftKey || event.ctrlKey;		var noObjectsSelected = this.selection.length === 0;		var currentIsSelected = this.selection.member(elementController);		// Rule #1: When there is nothing selected, select the clicked object.		if(currentIsSelectable && noObjectsSelected) {			this.setSelection([elementController]);			ORYX.Log.trace("Rule #1 applied for mouse down on %0", element.id);		// Rule #3: When at least one element is selected, and there is no		// control key pressed, and the clicked object is not selected, select		// the clicked object.		} else if(currentIsSelectable && !noObjectsSelected &&			!modifierKeyPressed && !currentIsSelected) {			this.setSelection([elementController]);			//var objectType = elementController.readAttributes();			//alert(objectType[0] + ": " + objectType[1]);			ORYX.Log.trace("Rule #3 applied for mouse down on %0", element.id);		// Rule #4: When the control key is pressed, and the current object is		// not selected, add it to the selection.		} else if(currentIsSelectable && modifierKeyPressed			&& !currentIsSelected) {							var newSelection = this.selection.clone();			newSelection.push(elementController)			this.setSelection(newSelection)			ORYX.Log.trace("Rule #4 applied for mouse down on %0", element.id);		// Rule #6		} else if(currentIsSelectable && currentIsSelected &&			modifierKeyPressed) {			var newSelection = this.selection.clone();			this.setSelection(newSelection.without(elementController))			ORYX.Log.trace("Rule #6 applied for mouse down on %0", elementController.id);		// Rule #5: When there is at least one object selected and no control		// key pressed, we're dragging.		/*} else if(currentIsSelectable && !noObjectsSelected			&& !modifierKeyPressed) {			if(this.log.isTraceEnabled())				this.log.trace("Rule #5 applied for mouse down on "+element.id);*/		// Rule #2: When clicked on something that is neither		// selectable nor movable, clear the selection, and return.		} else if (!currentIsSelectable && !currentIsMovable) {						this.setSelection([]);						ORYX.Log.trace("Rule #2 applied for mouse down on %0", element.id);			return;		// Rule #7: When the current object is not selectable but movable,		// it is probably a control. Leave the selection unchanged but set		// the movedObject to the current one and enable Drag. Dockers will		// be processed in the dragDocker plugin.		} else if(!currentIsSelectable && currentIsMovable && !(elementController instanceof ORYX.Core.Controls.Docker)) {						// TODO: If there is any moveable elements, do this in a plugin			//ORYX.Core.UIEnableDrag(event, elementController);			ORYX.Log.trace("Rule #7 applied for mouse down on %0", element.id);				// Rule #8: When the element is selectable and is currently selected and no 		// modifier key is pressed		} else if(currentIsSelectable && currentIsSelected &&			!modifierKeyPressed) {						this._subSelection = this._subSelection != elementController ? elementController : undefined;									this.setSelection(this.selection, this._subSelection);						ORYX.Log.trace("Rule #8 applied for mouse down on %0", element.id);		}						// prevent event from bubbling, return.		//Event.stop(event);		return;	},	_handleMouseMove: function(event, uiObj) {		return;	},	_handleMouseUp: function(event, uiObj) {		// get canvas.		var canvas = this.getCanvas();		// find the shape that is responsible for this elemement's id.		var elementController = uiObj;		//get event position		var evPos = this.eventCoordinates(event);		//Event.stop(event);	},	_handleMouseHover: function(event, uiObj) {		return;	},	_handleMouseOut: function(event, uiObj) {		return;	},	/**	 * Calculates the event coordinates to SVG document coordinates.	 * @param {Event} event	 * @return {SVGPoint} The event coordinates in the SVG document	 */	eventCoordinates: function(event) {		var canvas = this.getCanvas();		var svgPoint = canvas.node.ownerSVGElement.createSVGPoint();		svgPoint.x = event.clientX;		svgPoint.y = event.clientY;		var matrix = canvas.node.getScreenCTM();		return svgPoint.matrixTransform(matrix.inverse());	}};ORYX.Editor = Clazz.extend(ORYX.Editor);/** * Creates a new ORYX.Editor instance by fetching a model from given url and passing it to the constructur * @param {String} modelUrl The JSON URL of a model. * @param {Object} config Editor config passed to the constructur, merged with the response of the request to modelUrl */ORYX.Editor.createByUrl = function(modelUrl, config){    if(!config) config = {};        new Ajax.Request(modelUrl, {      method: 'GET',      onSuccess: function(transport) {        var editorConfig = Ext.decode(transport.responseText);        editorConfig = Ext.applyIf(editorConfig, config);        new ORYX.Editor(editorConfig);      }.bind(this)    });}// TODO Implement namespace awareness on attribute level./** * graft() function * Originally by Sean M. Burke from interglacial.com, altered for usage with * SVG and namespace (xmlns) support. Be sure you understand xmlns before * using this funtion, as it creates all grafted elements in the xmlns * provided by you and all element's attribures in default xmlns. If you * need to graft elements in a certain xmlns and wish to assign attributes * in both that and another xmlns, you will need to do stepwise grafting, * adding non-default attributes yourself or you'll have to enhance this * function. Latter, I would appreciate: martin�apfelfabrik.de * @param {Object} namespace The namespace in which * 					elements should be grafted. * @param {Object} parent The element that should contain the grafted * 					structure after the function returned. * @param {Object} t the crafting structure. * @param {Object} doc the document in which grafting is performed. */ORYX.Editor.graft = function(namespace, parent, t, doc) {    doc = (doc || (parent && parent.ownerDocument) || document);    var e;    if(t === undefined) {        throw "Can't graft an undefined value";    } else if(t.constructor == String) {        e = doc.createTextNode( t );    } else {        for(var i = 0; i < t.length; i++) {            if( i === 0 && t[i].constructor == String ) {                var snared;                snared = t[i].match( /^([a-z][a-z0-9]*)\.([^\s\.]+)$/i );                if( snared ) {                    e = doc.createElementNS(namespace, snared[1] );                    e.setAttributeNS(null, 'class', snared[2] );                    continue;                }                snared = t[i].match( /^([a-z][a-z0-9]*)$/i );                if( snared ) {                    e = doc.createElementNS(namespace, snared[1] );  // but no class                    continue;                }                // Otherwise:                e = doc.createElementNS(namespace, "span" );                e.setAttribute(null, "class", "namelessFromLOL" );            }            if( t[i] === undefined ) {                throw "Can't graft an undefined value in a list!";            } else if( t[i].constructor == String || t[i].constructor == Array ) {                this.graft(namespace, e, t[i], doc );            } else if(  t[i].constructor == Number ) {                this.graft(namespace, e, t[i].toString(), doc );            } else if(  t[i].constructor == Object ) {                // hash's properties => element's attributes                for(var k in t[i]) { e.setAttributeNS(null, k, t[i][k] ); }            } else {			}        }    }	if(parent) {	    parent.appendChild( e );	} else {	}    return e; // return the topmost created node};ORYX.Editor.provideId = function() {	var res = [], hex = '0123456789ABCDEF';	for (var i = 0; i < 36; i++) res[i] = Math.floor(Math.random()*0x10);	res[14] = 4;	res[19] = (res[19] & 0x3) | 0x8;	for (var i = 0; i < 36; i++) res[i] = hex[res[i]];	res[8] = res[13] = res[18] = res[23] = '-';	return "oryx_" + res.join('');};/** * When working with Ext, conditionally the window needs to be resized. To do * so, use this class method. Resize is deferred until 100ms, and all subsequent * resizeBugFix calls are ignored until the initially requested resize is * performed. */ORYX.Editor.resizeFix = function() {	if (!ORYX.Editor._resizeFixTimeout) {		ORYX.Editor._resizeFixTimeout = window.setTimeout(function() {			window.resizeBy(1,1);			window.resizeBy(-1,-1);			ORYX.Editor._resizefixTimeout = null;		}, 100); 	}};ORYX.Editor.Cookie = {		callbacks:[],			onChange: function( callback, interval ){			this.callbacks.push(callback);		this.start( interval )		},		start: function( interval ){				if( this.pe ){			return;		}				var currentString = document.cookie;				this.pe = new PeriodicalExecuter( function(){						if( currentString != document.cookie ){				currentString = document.cookie;				this.callbacks.each(function(callback){ callback(this.getParams()) }.bind(this));			}					}.bind(this), ( interval || 10000 ) / 1000);		},		stop: function(){		if( this.pe ){			this.pe.stop();			this.pe = null;		}	},			getParams: function(){		var res = {};				var p = document.cookie;		p.split("; ").each(function(param){ res[param.split("=")[0]] = param.split("=")[1];});				return res;	},			toString: function(){		return document.cookie;	}};/** * Workaround for SAFARI/Webkit, because * when trying to check SVGSVGElement of instanceof there is  * raising an error *  */ORYX.Editor.SVGClassElementsAreAvailable = true;ORYX.Editor.setMissingClasses = function() {		try {		SVGElement;	} catch(e) {		ORYX.Editor.SVGClassElementsAreAvailable = false;		SVGSVGElement 		= document.createElementNS('http://www.w3.org/2000/svg', 'svg').toString();		SVGGElement 		= document.createElementNS('http://www.w3.org/2000/svg', 'g').toString();		SVGPathElement 		= document.createElementNS('http://www.w3.org/2000/svg', 'path').toString();		SVGTextElement 		= document.createElementNS('http://www.w3.org/2000/svg', 'text').toString();		//SVGMarkerElement 	= document.createElementNS('http://www.w3.org/2000/svg', 'marker').toString();		SVGRectElement 		= document.createElementNS('http://www.w3.org/2000/svg', 'rect').toString();		SVGImageElement 	= document.createElementNS('http://www.w3.org/2000/svg', 'image').toString();		SVGCircleElement 	= document.createElementNS('http://www.w3.org/2000/svg', 'circle').toString();		SVGEllipseElement 	= document.createElementNS('http://www.w3.org/2000/svg', 'ellipse').toString();		SVGLineElement	 	= document.createElementNS('http://www.w3.org/2000/svg', 'line').toString();		SVGPolylineElement 	= document.createElementNS('http://www.w3.org/2000/svg', 'polyline').toString();		SVGPolygonElement 	= document.createElementNS('http://www.w3.org/2000/svg', 'polygon').toString();			}	}ORYX.Editor.checkClassType = function( classInst, classType ) {		if( ORYX.Editor.SVGClassElementsAreAvailable ){		return classInst instanceof classType	} else {		return classInst == classType	}};ORYX.Editor.makeExtModalWindowKeysave = function(facade) {	Ext.override(Ext.Window,{		beforeShow : function(){			delete this.el.lastXY;			delete this.el.lastLT;			if(this.x === undefined || this.y === undefined){				var xy = this.el.getAlignToXY(this.container, 'c-c');				var pos = this.el.translatePoints(xy[0], xy[1]);				this.x = this.x === undefined? pos.left : this.x;				this.y = this.y === undefined? pos.top : this.y;			}			this.el.setLeftTop(this.x, this.y);				if(this.expandOnShow){				this.expand(false);			}				if(this.modal){				facade.disableEvent(ORYX.CONFIG.EVENT_KEYDOWN);				Ext.getBody().addClass("x-body-masked");				this.mask.setSize(Ext.lib.Dom.getViewWidth(true), Ext.lib.Dom.getViewHeight(true));				this.mask.show();			}		},		afterHide : function(){	        this.proxy.hide();	        if(this.monitorResize || this.modal || this.constrain || this.constrainHeader){	            Ext.EventManager.removeResizeListener(this.onWindowResize, this);	        }	        if(this.modal){	            this.mask.hide();	            facade.enableEvent(ORYX.CONFIG.EVENT_KEYDOWN);	            Ext.getBody().removeClass("x-body-masked");	        }	        if(this.keyMap){	            this.keyMap.disable();	        }	        this.fireEvent("hide", this);	    },	    beforeDestroy : function(){	    	if(this.modal)	    		facade.enableEvent(ORYX.CONFIG.EVENT_KEYDOWN);	        Ext.destroy(	            this.resizer,	            this.dd,	            this.proxy,	            this.mask	        );	        Ext.Window.superclass.beforeDestroy.call(this);	    }	});}